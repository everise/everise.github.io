<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Everise&#39;s Notes</title>
  
  <subtitle>Quick Notes</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://everise.github.io/"/>
  <updated>2019-06-22T16:52:33.505Z</updated>
  <id>https://everise.github.io/</id>
  
  <author>
    <name>everise</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode 300: Longest Increasing Subsequence</title>
    <link href="https://everise.github.io/2019/06/22/LeetCode-300-Longest-Increasing-Subsequence/"/>
    <id>https://everise.github.io/2019/06/22/LeetCode-300-Longest-Increasing-Subsequence/</id>
    <published>2019-06-22T16:52:33.000Z</published>
    <updated>2019-06-22T16:52:33.505Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 295: Find Median from Data Stream</title>
    <link href="https://everise.github.io/2019/06/22/LeetCode-295-Find-Median-from-Data-Stream/"/>
    <id>https://everise.github.io/2019/06/22/LeetCode-295-Find-Median-from-Data-Stream/</id>
    <published>2019-06-22T16:52:08.000Z</published>
    <updated>2019-06-22T16:52:08.409Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 278: First Bad Version</title>
    <link href="https://everise.github.io/2019/06/22/LeetCode-278-First-Bad-Version/"/>
    <id>https://everise.github.io/2019/06/22/LeetCode-278-First-Bad-Version/</id>
    <published>2019-06-22T16:51:46.000Z</published>
    <updated>2019-06-22T16:51:46.080Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 265: Paint House II</title>
    <link href="https://everise.github.io/2019/06/22/LeetCode-265-Paint-House-II/"/>
    <id>https://everise.github.io/2019/06/22/LeetCode-265-Paint-House-II/</id>
    <published>2019-06-22T16:51:24.000Z</published>
    <updated>2019-06-22T16:51:24.151Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 200: Number of Islands</title>
    <link href="https://everise.github.io/2019/06/21/LeetCode-200-Number-of-Islands/"/>
    <id>https://everise.github.io/2019/06/21/LeetCode-200-Number-of-Islands/</id>
    <published>2019-06-22T03:30:31.000Z</published>
    <updated>2019-06-22T03:33:59.428Z</updated>
    
    <content type="html"><![CDATA[<p>Given a 2d grid map of ‘1’s (land) and ‘0’s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p><p><strong>Example 1:</strong><br><a id="more"></a><br>Input:<br>11110<br>11010<br>11000<br>00000</p><p>Output: 1</p><p><strong>Example 2:</strong></p><p>Input:<br>11000<br>11000<br>00100<br>00011</p><p>Output: 3</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] distance = &#123; &#123; <span class="number">1</span>, <span class="number">0</span> &#125;, &#123;-<span class="number">1</span>, <span class="number">0</span> &#125;, &#123; <span class="number">0</span>, <span class="number">1</span> &#125;, &#123; <span class="number">0</span>, -<span class="number">1</span> &#125; &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span> || grid[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        UnionFind uf = <span class="keyword">new</span> UnionFind(grid);</span><br><span class="line">        <span class="keyword">int</span> rows = grid.length;</span><br><span class="line">        <span class="keyword">int</span> cols = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span>[] d: distance) &#123;</span><br><span class="line">                        <span class="keyword">int</span> x = i + d[<span class="number">0</span>];</span><br><span class="line">                        <span class="keyword">int</span> y = j + d[<span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; x &lt; rows &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; cols &amp;&amp; grid[x][y] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                            <span class="keyword">int</span> id1 = i * cols + j;</span><br><span class="line">                            <span class="keyword">int</span> id2 = x * cols + y;</span><br><span class="line">                            uf.union(id1, id2);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uf.count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] father;</span><br><span class="line">        <span class="keyword">int</span> m, n;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        UnionFind(<span class="keyword">char</span>[][] grid) &#123;</span><br><span class="line">            m = grid.length;</span><br><span class="line">            n = grid[<span class="number">0</span>].length;</span><br><span class="line">            father = <span class="keyword">new</span> <span class="keyword">int</span>[m * n];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (grid[i][j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                        <span class="keyword">int</span> id = i * n + j;</span><br><span class="line">                        father[id] = id;</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> node1, <span class="keyword">int</span> node2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> find1 = find(node1);</span><br><span class="line">            <span class="keyword">int</span> find2 = find(node2);</span><br><span class="line">            <span class="keyword">if</span> (find1 != find2) &#123;</span><br><span class="line">                father[find1] = find2;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (father[node] == node) &#123;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">            father[node] = find(father[node]);</span><br><span class="line">            <span class="keyword">return</span> father[node];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DFS</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(grid.length == <span class="number">0</span> || grid[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; grid.length;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; grid[<span class="number">0</span>].length;j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                    traverse(grid, i, j);</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">traverse</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i == grid.length || j &lt; <span class="number">0</span> || j == grid[<span class="number">0</span>].length || grid[i][j] != <span class="string">'1'</span>) <span class="keyword">return</span>;</span><br><span class="line">        grid[i][j] = <span class="string">'2'</span>;</span><br><span class="line">        traverse(grid, i + <span class="number">1</span>, j);</span><br><span class="line">        traverse(grid, i - <span class="number">1</span>, j);</span><br><span class="line">        traverse(grid, i, j + <span class="number">1</span>);</span><br><span class="line">        traverse(grid, i, j - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Given a 2d grid map of ‘1’s (land) and ‘0’s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://everise.github.io/categories/LeetCode/"/>
    
      <category term="Amazon" scheme="https://everise.github.io/categories/LeetCode/Amazon/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 215: Kth Largest Element in an Array</title>
    <link href="https://everise.github.io/2019/06/15/LeetCode-215-Kth-Largest-Element-in-an-Array/"/>
    <id>https://everise.github.io/2019/06/15/LeetCode-215-Kth-Largest-Element-in-an-Array/</id>
    <published>2019-06-16T03:26:29.000Z</published>
    <updated>2019-06-16T03:27:29.872Z</updated>
    
    <content type="html"><![CDATA[<p>Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.</p><p><strong>Example 1:</strong></p><p>Input: [3,2,1,5,6,4] and k = 2<br>Output: 5</p><p><strong>Example 2:</strong></p><p>Input: [3,2,3,1,2,4,5,5,6] and k = 4<br>Output: 4</p><p><strong>Note:</strong><br>You may assume k is always valid, 1 ≤ k ≤ array’s length.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; q = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;(k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i: nums)&#123;</span><br><span class="line">        q.offer(i);</span><br><span class="line">        <span class="keyword">if</span>(q.size() &gt; k) q.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> q.peek();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct elem
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://everise.github.io/categories/LeetCode/"/>
    
      <category term="Amazon" scheme="https://everise.github.io/categories/LeetCode/Amazon/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 146: LRU Cache</title>
    <link href="https://everise.github.io/2019/06/15/LeetCode-146-LRU-Cache/"/>
    <id>https://everise.github.io/2019/06/15/LeetCode-146-LRU-Cache/</id>
    <published>2019-06-16T02:36:55.000Z</published>
    <updated>2019-06-16T19:27:11.553Z</updated>
    
    <content type="html"><![CDATA[<p>Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put.</p><p>get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.<br>put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.</p><p>The cache is initialized with a positive capacity.</p><p><strong>Follow up:</strong><br>Could you do both operations in O(1) time complexity?</p><p><strong>Example:</strong></p><p>LRUCache cache = new LRUCache( 2 /<em> capacity </em>/ );</p><p>cache.put(1, 1);<br>cache.put(2, 2);<br>cache.get(1);       // returns 1<br>cache.put(3, 3);    // evicts key 2<br>cache.get(2);       // returns -1 (not found)<br>cache.put(4, 4);    // evicts key 1<br>cache.get(1);       // returns -1 (not found)<br>cache.get(3);       // returns 3<br>cache.get(4);       // returns 4</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Integer&gt; map;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> val = map.get(key);</span><br><span class="line">        map.remove(key);</span><br><span class="line">        map.put(key, val);</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        map.remove(key);</span><br><span class="line">        map.put(key, value);</span><br><span class="line">        <span class="keyword">if</span> (map.size() &gt; <span class="keyword">this</span>.capacity) &#123;</span><br><span class="line">            map.remove(map.entrySet().iterator().next().getKey());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put.&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://everise.github.io/categories/LeetCode/"/>
    
      <category term="Amazon" scheme="https://everise.github.io/categories/LeetCode/Amazon/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 140: Word Break II</title>
    <link href="https://everise.github.io/2019/06/15/LeetCode-140-Word-Break-II/"/>
    <id>https://everise.github.io/2019/06/15/LeetCode-140-Word-Break-II/</id>
    <published>2019-06-16T02:36:07.000Z</published>
    <updated>2019-06-22T03:50:40.493Z</updated>
    
    <content type="html"><![CDATA[<p>Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences.</p><p><strong>Note:</strong><br><a id="more"></a><br>The same word in the dictionary may be reused multiple times in the segmentation.<br>You may assume the dictionary does not contain duplicate words.</p><p><strong>Example 1:</strong></p><p>Input:<br>s = “catsanddog”<br>wordDict = [“cat”, “cats”, “and”, “sand”, “dog”]<br>Output:<br>[<br>  “cats and dog”,<br>  “cat sand dog”<br>]</p><p><strong>Example 2:</strong></p><p>Input:<br>s = “pineapplepenapple”<br>wordDict = [“apple”, “pen”, “applepen”, “pine”, “pineapple”]<br>Output:<br>[<br>  “pine apple pen apple”,<br>  “pineapple pen apple”,<br>  “pine applepen apple”<br>]<br>Explanation: Note that you are allowed to reuse a dictionary word.</p><p><strong>Example 3:</strong></p><p>Input:<br>s = “catsandog”<br>wordDict = [“cats”, “dog”, “sand”, “and”, “cat”]<br>Output:<br>[]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.既然想到动态规划剪枝了，再多想以下，我们不只是需要考虑当前子串在字典中，还要考虑当前子串之前的字符串也在字典中，这样将大大减少搜索路径。</span><br><span class="line"><span class="number">2</span>.我们查找是否包含在字典中是从前往后找的，那么我们找相关路径的时候反向遍历将会大大减少搜索路径。</span><br><span class="line">实现了以上两点就已经大大优化了我们的检索。</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; result;</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">wordBreak</span><span class="params">(String s, Set&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">    result = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="keyword">int</span> n = s.length();</span><br><span class="line">    <span class="comment">//对每一个i都形成一个可以跳跃的点</span></span><br><span class="line">    List&lt;Integer&gt;[] pointer = <span class="keyword">new</span> List[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) pointer[i]=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="comment">//动态规划形成跳跃点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=i;j++)&#123;</span><br><span class="line">            <span class="comment">//递归的保证j-1可以形成单词，大大地剪枝</span></span><br><span class="line">            <span class="keyword">if</span>(wordDict.contains(s.substring(j,i+<span class="number">1</span>))&amp;&amp;(j==<span class="number">0</span>||pointer[j-<span class="number">1</span>].size()&gt;<span class="number">0</span>))</span><br><span class="line">                pointer[i].add(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从后往前的递归</span></span><br><span class="line">    helper(pointer, s, n-<span class="number">1</span>, <span class="string">""</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//DFS</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(List&lt;Integer&gt;[] pointer, String s, <span class="keyword">int</span> i, String pattern)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        result.add(pattern);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(Integer item:pointer[i])&#123;</span><br><span class="line">        String nextPattern = pattern.length()==<span class="number">0</span>?s.substring(item,i+<span class="number">1</span>):s.substring(item,i+<span class="number">1</span>)+<span class="string">" "</span>+pattern;</span><br><span class="line">        helper(pointer, s, item-<span class="number">1</span>, nextPattern);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://everise.github.io/categories/LeetCode/"/>
    
      <category term="Amazon" scheme="https://everise.github.io/categories/LeetCode/Amazon/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 138: Copy List with Random Pointer</title>
    <link href="https://everise.github.io/2019/06/15/LeetCode-138-Copy-List-with-Random-Pointer/"/>
    <id>https://everise.github.io/2019/06/15/LeetCode-138-Copy-List-with-Random-Pointer/</id>
    <published>2019-06-16T02:35:41.000Z</published>
    <updated>2019-06-16T02:35:41.657Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 133: Clone Graph</title>
    <link href="https://everise.github.io/2019/06/15/LeetCode-133-Clone-Graph/"/>
    <id>https://everise.github.io/2019/06/15/LeetCode-133-Clone-Graph/</id>
    <published>2019-06-16T02:35:15.000Z</published>
    <updated>2019-06-16T02:37:46.177Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="LeetCode" scheme="https://everise.github.io/categories/LeetCode/"/>
    
      <category term="Amazon" scheme="https://everise.github.io/categories/LeetCode/Amazon/"/>
    
    
  </entry>
  
</feed>
