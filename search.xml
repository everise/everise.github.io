<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LeetCode 662: Maximum Width of Binary Tree]]></title>
    <url>%2F2018%2F10%2F09%2FLeetCode-662-Maximum-Width-of-Binary-Tree%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 872: Leaf-Similar Trees]]></title>
    <url>%2F2018%2F10%2F09%2FLeetCode-872-Leaf-Similar-Trees%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 742: Closest Leaf in a Binary Tree]]></title>
    <url>%2F2018%2F10%2F09%2FLeetCode-742-Closest-Leaf-in-a-Binary-Tree%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 687: Longest Univalue Path]]></title>
    <url>%2F2018%2F10%2F09%2FLeetCode-687-Longest-Univalue-Path%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 653: Two Sum IV - Input is a BST]]></title>
    <url>%2F2018%2F10%2F09%2FLeetCode-653-Two-Sum-IV-Input-is-a-BST%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 652: Find Duplicate Subtrees]]></title>
    <url>%2F2018%2F10%2F09%2FLeetCode-652-Find-Duplicate-Subtrees%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 572: Subtree of Another Tree]]></title>
    <url>%2F2018%2F10%2F09%2FLeetCode-572-Subtree-of-Another-Tree%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 549: Binary Tree Longest Consecutive Sequence II]]></title>
    <url>%2F2018%2F10%2F09%2FLeetCode-549-Binary-Tree-Longest-Consecutive-Sequence-II%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 543: Diameter of Binary Tree]]></title>
    <url>%2F2018%2F10%2F09%2FLeetCode-543-Diameter-of-Binary-Tree%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 250: Count Univalue Subtrees]]></title>
    <url>%2F2018%2F10%2F06%2FLeetCode-250-Count-Univalue-Subtrees%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 226: Invert Binary Tree]]></title>
    <url>%2F2018%2F10%2F06%2FLeetCode-226-Invert-Binary-Tree%2F</url>
    <content type="text"><![CDATA[12345type TreeNode struct &#123; Val int Left *TreeNode Right *TreeNode&#125; 123456789101112131415func invertTree(root *TreeNode) *TreeNode &#123; if root == nil &#123; return root &#125; var left, right *TreeNode if root.Left != nil &#123; right = invertTree(root.Left) &#125; if root.Right != nil &#123; left = invertTree(root.Right) &#125; root.Left = left root.Right = right return root&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 222: Count Complete Tree Nodes]]></title>
    <url>%2F2018%2F10%2F06%2FLeetCode-222-Count-Complete-Tree-Nodes%2F</url>
    <content type="text"><![CDATA[12345type TreeNode struct &#123; Val int Left *TreeNode Right *TreeNode&#125; 1234567891011121314151617181920func countNodes(root *TreeNode) int &#123; if root == nil &#123; return 0 &#125; res := 0 queue := []*TreeNode&#123;root&#125; for len(queue) != 0 &#123; res = res + len(queue) for _, v := range queue &#123; if v.Left != nil &#123; queue = append(queue, v.Left) &#125; if v.Right != nil &#123; queue = append(queue, v.Right) &#125; queue = queue[1:] &#125; &#125; return res&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 124: Binary Tree Maximum Path Sum]]></title>
    <url>%2F2018%2F10%2F06%2FLeetCode-124-Binary-Tree-Maximum-Path-Sum%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 110: Balanced Binary Tree]]></title>
    <url>%2F2018%2F10%2F06%2FLeetCode-110-Balanced-Binary-Tree%2F</url>
    <content type="text"><![CDATA[12345type TreeNode struct &#123; Val int Left *TreeNode Right *TreeNode&#125; 123456789101112131415161718192021func checkDepth(root *TreeNode) int &#123; if root == nil &#123; return 0 &#125; left := checkDepth(root.Left) if left == -1 &#123; return -1 &#125; right := checkDepth(root.Right) if right == -1 &#123; return -1 &#125; if right &gt; left &#123; left, right = right, left &#125; diff := left - right if diff &gt; 1 &#123; return -1 &#125; return 1 + left&#125; 123456func isBalanced(root *TreeNode) bool &#123; if checkDepth(root) == -1 &#123; return false &#125; return true&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 108: Convert Sorted Array to Binary Search Tree]]></title>
    <url>%2F2018%2F10%2F06%2FLeetCode-108-Convert-Sorted-Array-to-Binary-Search-Tree%2F</url>
    <content type="text"><![CDATA[12345type TreeNode struct &#123; Val int Left *TreeNode Right *TreeNode&#125; 12345678910111213141516171819func sortedArrayToBST(nums []int) *TreeNode &#123; if len(nums) == 0 &#123; return nil &#125;else if len(nums) == 1 &#123; res1 := &amp;TreeNode&#123;Val: nums[0],Left: nil,Right: nil&#125; return res1 &#125;else if len(nums) == 2 &#123; resNode := &amp;TreeNode&#123;Val: nums[0],Left: nil,Right: nil&#125; res2 := &amp;TreeNode&#123;Val: nums[1],Left: resNode,Right: nil&#125; return res2 &#125; key := len(nums) / 2 left := nums[:key] right := nums[key+1:] res := &amp;TreeNode&#123;Val: nums[key], Left: sortedArrayToBST(left),Right: sortedArrayToBST(right)&#125; return res&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 104: Maximum Depth of Binary Tree]]></title>
    <url>%2F2018%2F10%2F06%2FLeetCode-104-Maximum-Depth-of-Binary-Tree%2F</url>
    <content type="text"><![CDATA[12345type TreeNode struct &#123; Val int Left *TreeNode Right *TreeNode&#125; 123456789101112131415161718192021func maxDepth(root *TreeNode) int &#123; res := 0 if root == nil &#123; return res &#125; var queue []*TreeNode queue = append(queue, root) for len(queue) != 0 &#123; for _, v := range queue &#123; if v.Left != nil &#123; queue = append(queue, v.Left) &#125; if v.Right != nil &#123; queue = append(queue, v.Right) &#125; queue = queue[1:] &#125; res++ &#125; return res&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 103: Binary Tree Zigzag Level Order Traversal]]></title>
    <url>%2F2018%2F10%2F06%2FLeetCode-103-Binary-Tree-Zigzag-Level-Order-Traversal%2F</url>
    <content type="text"><![CDATA[12345type TreeNode struct &#123; Val int Left *TreeNode Right *TreeNode&#125; 12345678910111213141516171819202122232425262728293031323334353637383940func zigzagLevelOrder(root *TreeNode) [][]int &#123; var res [][]int if root == nil &#123; return res &#125; var s1, s2 []*TreeNode s1 = append(s1, root) for len(s1) != 0 || len(s2) != 0 &#123; var level1 []int for _, v1 := range s1 &#123; level1 = append(level1, v1.Val) if v1.Right != nil &#123; s2 = append(s2, v1.Right) &#125; if v1.Left != nil &#123; s2 = append(s2, v1.Left) &#125; s1 = s1[1:] &#125; if len(level1) != 0 &#123; res = append(res, level1) &#125; var level2 []int for _, v2 := range s2 &#123; level2 = append(level2, v2.Val) if v2.Left != nil &#123; s1 = append(s1, v2.Left) &#125; if v2.Right != nil &#123; s1 = append(s1, v2.Right) &#125; s2 = s2[1:] &#125; if len(level2) != 0 &#123; res = append(res, level2) &#125; &#125; return res&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Binary Tree</tag>
        <tag>Not solved</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 102: Binary Tree Level Order Traversal]]></title>
    <url>%2F2018%2F10%2F06%2FLeetCode-102-Binary-Tree-Level-Order-Traversal%2F</url>
    <content type="text"><![CDATA[12345type TreeNode struct &#123; Val int Left *TreeNode Right *TreeNode&#125; 1234567891011121314151617181920212223func levelOrder(root *TreeNode) [][]int &#123; var res [][]int if root == nil &#123; return res &#125; var queue []*TreeNode queue = append(queue, root) for len(queue) != 0 &#123; var oneLevel []int for _, v := range queue &#123; oneLevel = append(oneLevel, v.Val) if v.Left != nil &#123; queue = append(queue, v.Left) &#125; if v.Right != nil &#123; queue = append(queue, v.Right) &#125; queue = queue[1:] &#125; res = append(res,oneLevel) &#125; return res&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 98: Validate Binary Search Tree]]></title>
    <url>%2F2018%2F10%2F06%2FLeetCode-98-Validate-Binary-Search-Tree%2F</url>
    <content type="text"><![CDATA[12345type TreeNode struct &#123; Val int Left *TreeNode Right *TreeNode&#125; 12345678910func isBST(root *TreeNode, min, max int) bool &#123; if root == nil &#123; return true &#125; if root.Val &lt;= min || root.Val &gt;= max &#123; return false &#125; return isBST(root.Left,min,root.Val) &amp;&amp; isBST(root.Right,root.Val,max)&#125; 123func isValidBST(root *TreeNode) bool &#123; return isBST(root, -int(^uint(0) &gt;&gt; 1)-1, int(^uint(0) &gt;&gt; 1))&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 725: Split Linked List in Parts]]></title>
    <url>%2F2018%2F10%2F04%2FLeetCode-725-Split-Linked-List-in-Parts%2F</url>
    <content type="text"><![CDATA[1234type ListNode struct &#123; Val int Next *ListNode&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546func splitListToParts(root *ListNode, k int) []*ListNode &#123; var res []*ListNode var n int tmp := root for tmp != nil &#123; tmp = tmp.Next n++ &#125; if n &lt; k &#123; for t := 0; t &lt; n; t++ &#123; shortTmp := root root = root.Next shortTmp.Next = nil res = append(res, shortTmp) &#125; for u := n; u &lt; k; u++ &#123; shortTmp := new(ListNode) res = append(res, shortTmp.Next) &#125; return res &#125; usual, more := n / k, n % k for i := 0; i &lt; more; i++ &#123; listTmp := root for t := 0; t &lt; usual; t++ &#123; root = root.Next &#125; now := root.Next root.Next = nil res = append(res, listTmp) root = now &#125; for j := 0; j &lt; k - more; j++ &#123; longTmp := root for n := 0; n &lt; usual - 1; n++ &#123; root = root.Next &#125; now := root.Next root.Next = nil res = append(res, longTmp) root = now &#125; return res&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 445: Add Two Numbers II]]></title>
    <url>%2F2018%2F10%2F04%2FLeetCode-445-Add-Two-Numbers-II%2F</url>
    <content type="text"><![CDATA[1234type ListNode struct &#123; Val int Next *ListNode&#125; 12345678910111213141516171819202122232425262728293031func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode &#123; var s1, s2 []int for l1 != nil &#123; s1 = append(s1, l1.Val) l1 = l1.Next &#125; for l2 != nil &#123; s2 = append(s2, l2.Val) l2 = l2.Next &#125; var sum int res := new(ListNode) for len(s1) != 0 || len(s2) != 0 &#123; if len(s1) != 0 &#123; sum += s1[len(s1)-1] s1 = s1[:len(s1)-1] &#125; if len(s2) != 0 &#123; sum += s2[len(s2)-1] s2 = s2[:len(s2)-1] &#125; res.Val = sum % 10 head := &amp;ListNode&#123;sum / 10, res&#125; res = head sum = sum / 10 &#125; if res.Val == 0 &#123; return res.Next &#125; return res&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 206: Reverse Linked List]]></title>
    <url>%2F2018%2F10%2F04%2FLeetCode-206-Reverse-Linked-List%2F</url>
    <content type="text"><![CDATA[1234type ListNode struct &#123; Val int Next *ListNode&#125; 12345678910func reverseList(head *ListNode) *ListNode &#123; var res *ListNode for head != nil &#123; temp := head.Next head.Next = res res = head head = temp &#125; return res&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 19: Remove Nth Node From End of List]]></title>
    <url>%2F2018%2F10%2F04%2FLeetCode-19-Remove-Nth-Node-From-End-of-List%2F</url>
    <content type="text"><![CDATA[1234type ListNode struct &#123; Val int Next *ListNode&#125; 123456789101112131415161718192021func removeNthFromEnd(head *ListNode, n int) *ListNode &#123; ahead, res := head, head for i := 0; i &lt; n; i++ &#123; ahead = ahead.Next &#125; if ahead == nil &#123; return res.Next &#125; for ahead.Next != nil &#123; ahead = ahead.Next head = head.Next &#125; if head.Next != nil &#123; head.Next = head.Next.Next &#125;else &#123; head.Next = nil &#125; return res&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 817: Linked List Components]]></title>
    <url>%2F2018%2F10%2F03%2FLeetCode-817-Linked-List-Components%2F</url>
    <content type="text"><![CDATA[1234type ListNode struct &#123; Val int Next *ListNode&#125; 12345678910111213141516171819func numComponents(head *ListNode, G []int) int &#123; m := make(map[int]bool) for _, v := range G &#123; m[v] = true &#125; var res int for head.Next != nil &#123; _, exist1 := m[head.Val] _, exist2 := m[head.Next.Val] if exist1 &amp;&amp; (head.Next == nil || !exist2) &#123; res++ &#125; head = head.Next &#125; if _, exist := m[head.Val]; exist &#123; res++ &#125; return res&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 369: Plus One Linked List]]></title>
    <url>%2F2018%2F10%2F03%2FLeetCode-369-Plus-One-Linked-List%2F</url>
    <content type="text"><![CDATA[1234type ListNode struct &#123; Val int Next *ListNode&#125; 1234567891011121314func everyOne(head *ListNode) (*ListNode, int) &#123; if head.Next == nil &#123; carry := (head.Val + 1) / 10 head.Val = (head.Val + 1) % 10 return head, carry &#125; res, carry := everyOne(head.Next) if carry == 1 &#123; carry = (head.Val + 1) / 10 head.Val = (head.Val + 1) % 10 &#125; head.Next = res return head, carry&#125; 12345678func plusOne(head *ListNode) *ListNode &#123; res, carry := everyOne(head) if carry == 1 &#123; newHead := &amp;ListNode&#123;1, res&#125; return newHead &#125; return res&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 203: Remove Linked List Elements]]></title>
    <url>%2F2018%2F10%2F03%2FLeetCode-203-Remove-Linked-List-Elements%2F</url>
    <content type="text"><![CDATA[1234type ListNode struct &#123; Val int Next *ListNode&#125; 12345678910111213func removeElements(head *ListNode, val int) *ListNode &#123; newHead := new(ListNode) newHead.Next = head tail := newHead for tail != nil &#123; if tail.Next.Val == val &#123; tail.Next = tail.Next.Next &#125;else &#123; tail = tail.Next &#125; &#125; return newHead.Next&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 21: Merge Two Sorted Lists]]></title>
    <url>%2F2018%2F10%2F03%2FLeetCode-21-Merge-Two-Sorted-Lists%2F</url>
    <content type="text"><![CDATA[1234type ListNode struct &#123; Val int Next *ListNode&#125; 123456789101112131415161718192021func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode &#123; head := new(ListNode) tail := head for l1 != nil &amp;&amp; l2 != nil &#123; if l1.Val &lt;= l2.Val &#123; tail.Next = l1 tail = l1 l1 = l1.Next &#125;else &#123; tail.Next = l2 tail = l2 l2 = l2.Next &#125; &#125; if l1 == nil &#123; tail.Next = l2 &#125;else &#123; tail.Next = l1 &#125; return head.Next&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 750: Number Of Corner Rectangles]]></title>
    <url>%2F2018%2F10%2F03%2FLeetCode-750-Number-Of-Corner-Rectangles%2F</url>
    <content type="text"><![CDATA[123456789101112131415func countCornerRectangles(grid [][]int) int &#123; var res int for i := 0; i &lt; len(grid); i++ &#123; for j := i + 1; j &lt; len(grid); j++ &#123; count := 0 for k := 0; k &lt; len(grid[0]); k++ &#123; if grid[i][k] == 1 &amp;&amp; grid[j][k] == 1 &#123; count++ &#125; &#125; res += count * (count - 1) / 2 &#125; &#125; return res &#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode 418: Sentence Screen Fitting]]></title>
    <url>%2F2018%2F10%2F02%2FLeetcode-418-Sentence-Screen-Fitting%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526func wordsTyping(sentence []string, rows int, cols int) int &#123; left, res, count := cols, 0, 0 for i := 0; i &lt; rows; i++ &#123; for &#123; if count == len(sentence) &#123; count = 0 res += 1 &#125; if left &lt; len(sentence[count]) &#123; left = cols break &#125;else if left == len(sentence[count]) &#123; count++ left = cols break &#125; left -= len(sentence[count]) + 1 count++ &#125; &#125; if count == len(sentence) &#123; count = 0 res += 1 &#125; return res&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode 416: Partition Equal Subset Sum]]></title>
    <url>%2F2018%2F10%2F02%2FLeetcode-416-Partition-Equal-Subset-Sum%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920func canPartition(nums []int) bool &#123; var sum, target int for _, v := range nums &#123; sum += v &#125; if sum % 2 == 1 &#123; return false &#125;else &#123; target = sum &gt;&gt; 1 &#125; dp := make([]bool, target + 1) dp[0] = true for _, n := range nums &#123; for i := target; i &gt;= n; i-- &#123; dp[i] = dp[i] || dp[i - n] &#125; &#125; return dp[target] &#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[General Notes of Golang]]></title>
    <url>%2F2018%2F09%2F28%2FGeneral-Notes-of-Golang%2F</url>
    <content type="text"></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 375: Guess Number Higher or Lower II]]></title>
    <url>%2F2018%2F09%2F28%2FLeetCode-375-Guess-Number-Higher-or-Lower-II%2F</url>
    <content type="text"><![CDATA[1234567func getMoneyAmount(n int) int &#123; m := make([][]int, n + 1) for t := range m &#123; m[t] = make([]int, n + 1) &#125; return guessMoney(1, n, m)&#125; 123456789101112131415161718192021222324func guessMoney(start, end int, m [][]int) int &#123; if start &gt;= end &#123; return 0 &#125; if m[start][end] &gt; 0 &#123; return m[start][end] &#125; res := 0x7FFFFFFF for i := start; i &lt; end; i++ &#123; a := guessMoney(start, i - 1, m) b := guessMoney(i + 1, end, m) if a &gt; b &#123; if i + a &lt; res &#123; res = i + a &#125; &#125;else &#123; if i + b &lt; res &#123; res = i + b &#125; &#125; &#125; m[start][end] = res return res&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
        <tag>Minimax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 304: Range Sum Query 2D - Immutable]]></title>
    <url>%2F2018%2F09%2F28%2FLeetCode-304-Range-Sum-Query-2D-Immutable%2F</url>
    <content type="text"><![CDATA[123type NumMatrix struct &#123; dp [][]int&#125; 12345678910111213141516171819202122func Constructor(matrix [][]int) NumMatrix &#123; var m, n int if len(matrix) == 0 || len(matrix[0]) == 0 &#123; m, n = 0, 0 &#125;else &#123; m, n = len(matrix), len(matrix[0]) &#125; dp := make([][]int, m + 1) for v := range dp &#123; dp[v] = make([]int, n + 1) &#125; for i := 1; i &lt;= m; i++ &#123; for j := 1; j &lt;=n; j++ &#123; dp[i][j] = matrix[i-1][j-1] + dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1] &#125; &#125; return NumMatrix&#123;dp: dp&#125;&#125;func (this *NumMatrix) SumRegion(row1 int, col1 int, row2 int, col2 int) int &#123; return this.dp[row2+1][col2+1] - this.dp[row2+1][col1] - this.dp[row1][col2+1] + this.dp[row1][col1]&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 221: Maximal Square]]></title>
    <url>%2F2018%2F09%2F28%2FLeetCode-221-Maximal-Square%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435func maximalSquare(matrix [][]byte) int &#123; if len(matrix) == 0 || len(matrix[0]) == 0 &#123; return 0 &#125; res := 0 dp := make([][]int, len(matrix)) for t := range dp &#123; dp[t] = make([]int, len(matrix[0])) &#125; for i := range matrix &#123; for j := range matrix[i] &#123; if i == 0 || j == 0 &#123; dp[i][j] = int(matrix[i][j]) - '0' &#125;else if int(matrix[i][j]) == '1' &#123; if dp[i-1][j] &lt; dp[i][j-1] &#123; if dp[i-1][j] &lt; dp[i-1][j-1] &#123; dp [i][j] = dp[i-1][j] + 1 &#125;else &#123; dp[i][j] = dp[i-1][j-1] + 1 &#125; &#125;else &#123; if dp[i][j-1] &lt; dp[i-1][j-1] &#123; dp [i][j] = dp[i][j-1] + 1 &#125;else &#123; dp[i][j] = dp[i-1][j-1] + 1 &#125; &#125; &#125; if res &lt; dp[i][j] &#123; res = dp[i][j] &#125; &#125; &#125; return res * res &#125; 1234567891011121314151617181920212223242526272829303132333435func maximalSquare(matrix [][]byte) int &#123; if len(matrix) == 0 || len(matrix[0]) == 0 &#123; return 0 &#125; dp := [2][]int&#123;make([]int, len(matrix[0])+1), make([]int, len(matrix[0])+1)&#125; res, curr := 0, 0 for i := range matrix &#123; prev := curr curr = 1 - curr for j := range matrix[i] &#123; if matrix[i][j] == '0' &#123; dp[curr][j+1] = 0 continue &#125; if dp[curr][j] &lt; dp[prev][j] &#123; if dp[curr][j] &lt; dp[prev][j+1] &#123; dp[curr][j+1] = dp[curr][j] + 1 &#125;else &#123; dp[curr][j+1] = dp[prev][j+1] + 1 &#125; &#125;else &#123; if dp[prev][j] &lt; dp[prev][j+1] &#123; dp[curr][j+1] = dp[prev][j] + 1 &#125;else &#123; dp[curr][j+1] = dp[prev][j+1] + 1 &#125; &#125; if res &lt; dp[curr][j+1] &#123; res = dp[curr][j+1] &#125; &#125; &#125; return res * res&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 198: House Robber]]></title>
    <url>%2F2018%2F09%2F28%2FLeetCode-198-House-Robber%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324func rob(nums []int) int &#123; var even, odd, res int for i, v := range nums &#123; if i % 2 == 0 &#123; if even + v &gt; odd &#123; even = even + v &#125;else &#123; even = odd &#125; &#125;else &#123; if odd + v &gt; even &#123; odd = odd + v &#125;else &#123; odd = even &#125; &#125; &#125; if even &gt; odd &#123; res = even &#125;else &#123; res = odd &#125; return res&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 188: Best Time to Buy and Sell Stock IV]]></title>
    <url>%2F2018%2F09%2F28%2FLeetCode-188-Best-Time-to-Buy-and-Sell-Stock-IV%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122func maxProfit(k int, prices []int) int &#123; if k &gt; len(prices) &#123; k = len(prices) &#125; var bp, sp []int for i := 0; i &lt; k; i++ &#123; bp = append(bp, -0x80000000) sp = append(sp, 0) &#125; sp = append(sp, 0) for _, v := range prices &#123; for j := 0; j &lt; k; j++ &#123; if bp[i] &lt; sp[i] - v &#123; bp[i] = sp[i] - v &#125; if sp[i+1] &lt; v + bp[i] &#123; sp[i+1] = v + bp[i] &#125; &#125; &#125; return sp[k]&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 139: Word Break]]></title>
    <url>%2F2018%2F09%2F28%2FLeetCode-139-Word-Break%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526func wordBreak(s string, wordDict []string) bool &#123; if len(wordDict) == 0 &#123; return false &#125; dict := make(map[string]bool) length := []int for _, v := range wordDict &#123; if _, exist := dict[v]; !exist &#123; dict[v] = true length = append(length,len(v)) &#125; &#125; dp := make([]bool, len(s)+1) dp[0] = true for i := 0; i &lt; len(s); i++ &#123; if !dp[i] &#123; continue &#125; for _, size := range length &#123; dp[i+size] = dp[i+size] || dict[s[i:i+size]] &#125; &#125; return dp[len(s)]&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 10: Regular Expression Matching]]></title>
    <url>%2F2018%2F09%2F28%2FLeetCode-10-Regular-Expression-Matching%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819func isMatch(s string, p string) bool &#123; dp := make([][]bool, len(s)+1) for i := range dp &#123; dp[i] = make([]bool, len(p)+1) &#125; dp[len(s)][len(p)] = true for i := len(s); i &gt;= 0; i-- &#123; for j := len(p) - 1; j &gt;= 0; j-- &#123; firstMatch := i &lt; len(s) &amp;&amp; (p[j] == s[i] || p[j] == '.') if j+1 &lt; len(p) &amp;&amp; p[j + 1] == '*' &#123; dp[i][j] = dp[i][j + 2] || firstMatch &amp;&amp; dp[i + 1][j] &#125;else &#123; dp[i][j] = firstMatch &amp;&amp; dp[i + 1][j + 1] &#125; &#125; &#125; return dp[0][0]&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 8: String to Integer (atoi)]]></title>
    <url>%2F2018%2F09%2F28%2FLeetCode-8-String-to-Integer-atoi%2F</url>
    <content type="text"><![CDATA[This is following: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748func myAtoi(str string) int &#123; s := strings.TrimSpace(str) if len(s) == 0 &#123; return 0 &#125; symbol := ‘+’ if s[0] == ‘-’ &#123; symbol = ‘-’ s = s[1:] &#125;else s[0] == ‘+’ &#123; s = s[1:] &#125; if len(s) == 0 &#123; return 0 &#125; if s[0] &lt; ‘0’ || s[0] &gt; ‘9’ &#123; return 0 &#125; for i := range s &#123; if s[i] &lt; ‘0’ || s[i] &gt; ‘9’ &#123; s = s[:i] break &#125; &#125; res := 0 for _, ch := range []byte(s) &#123; ch -= ‘0’ if ch &gt; 9 &#123; return 0 &#125; res = res*10 + int(ch) if res &gt; 0x7FFFFFFF &#123; if symbol == ‘-’ &#123; return -0x80000000 &#125; return 0x7FFFFFFF &#125; &#125; if symbol == ‘-’ &#123; res = -res &#125; return res&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 7: Reverse Integer]]></title>
    <url>%2F2018%2F09%2F28%2FLeetCode-7-Reverse-Integer%2F</url>
    <content type="text"><![CDATA[1234567891011121314func reverse(x int) int &#123; res := 0 for &#123; res = res * 10 + x % 10 if x / 10 == 0 &#123; break &#125; x = x / 10 &#125; if x &lt; -0x80000000 || x &gt; 0x7FFFFFFF &#123; return 0 &#125; return res&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 5: Longest Palindromic Substring]]></title>
    <url>%2F2018%2F09%2F28%2FLeetCode-5-Longest-Palindromic-Substring%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526func longestPalindrome(s string) string &#123; if len(s) &lt; 2 &#123; return s &#125; index, max := 0, 0 for i := 0; i &lt; len(s) &#123; if len(s) - i &gt; max / 2 &#123; break &#125; begin, end := i, i for end &lt; len(s) - 1 &amp;&amp; s[i] == s[i+1] &#123; end++ &#125; i = end + 1 for end &lt; len(s) - 1 &amp;&amp; begin &gt; 0 &amp;&amp; s[end+1] == s[begin-1] &#123; end++ begin-- &#125; length := end - begin + 1 if max &lt; length &#123; max = length index = begin &#125; &#125; return s[index: index + max]&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 3: Longest Substring Without Repeating Characters]]></title>
    <url>%2F2018%2F09%2F28%2FLeetCode-3-Longest-Substring-Without-Repeating-Characters%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021func lengthOfLongestSubstring(s string) int &#123; m := make(map[uint8]int) res := 0 start, end := 0, 0 for end &lt; len(s) &#123; if p, exist := m[s[end]]; exist &#123; start = p + 1 end = start for k, _ := range m &#123; delete(m, k) &#125; &#125;else &#123; m[s[end]] = end if end - start + 1 &gt; res &#123; res = end - start + 1 &#125; end++ &#125; &#125; return res&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Hash Table</tag>
        <tag>String</tag>
        <tag>Two Pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 2: Add Two Numbers]]></title>
    <url>%2F2018%2F09%2F28%2FLeetCode-2-Add-Two-Numbers%2F</url>
    <content type="text"><![CDATA[1234type ListNode struct &#123; Val interface&#123;&#125; Next *ListNode&#125; 123456789101112131415161718192021func addTwoNumbers(a, b *ListNode) *ListNode &#123; head := new(ListNode) node := head carray := 0 for a != nil || b != nil || carray != 0 &#123; sum := carry if a != nil &#123; sum += a.Val a = a.Next &#125; if b != nil &#123; sum += b.Val b = b.Next &#125; carry = sum / 10 node.Next = new(ListNode) node.Next.Val = sum % 10 node = node.Next &#125; return head.Next&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 1: Two Sum]]></title>
    <url>%2F2018%2F09%2F27%2FLeetCode-1-Two-Sum%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617func twoSum(nums []int, target int) []int &#123; var res []int m := make(map[int]int) for i := 0; i &lt; len(nums); i++ &#123; if v,exist := m[target-nums[i]];exist &#123; if v &lt; i &#123; res = append(res,v,i) &#125;else &#123; res = append(res,i,v) &#125; break &#125;else &#123; m[nums[i]] = i &#125; &#125; return res&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Hash Table</tag>
      </tags>
  </entry>
</search>
