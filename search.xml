<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LeetCode 817: Linked List Components]]></title>
    <url>%2F2018%2F10%2F03%2FLeetCode-817-Linked-List-Components%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 369: Plus One Linked List]]></title>
    <url>%2F2018%2F10%2F03%2FLeetCode-369-Plus-One-Linked-List%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 203: Remove Linked List Elements]]></title>
    <url>%2F2018%2F10%2F03%2FLeetCode-203-Remove-Linked-List-Elements%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 21: Merge Two Sorted Lists]]></title>
    <url>%2F2018%2F10%2F03%2FLeetCode-21-Merge-Two-Sorted-Lists%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 750: Number Of Corner Rectangles]]></title>
    <url>%2F2018%2F10%2F03%2FLeetCode-750-Number-Of-Corner-Rectangles%2F</url>
    <content type="text"><![CDATA[12345678910111213141516func countCornerRectangles(grid [][]int) int &#123; var res int for i := 0; i &lt; len(grid); i++ &#123; for j := i + 1; j &lt; len(grid); j++ &#123; cnt := 0 for k := 0; k &lt; len(grid[0]); k++ &#123; if grid[i][k] == 1 &amp;&amp; grid[j][k] == 1 &#123; cnt++ &#125; &#125; res += cnt * (cnt - 1) / 2 &#125; &#125; return res &#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode 418: Sentence Screen Fitting]]></title>
    <url>%2F2018%2F10%2F02%2FLeetcode-418-Sentence-Screen-Fitting%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526func wordsTyping(sentence []string, rows int, cols int) int &#123; left, res, count := cols, 0, 0 for i := 0; i &lt; rows; i++ &#123; for &#123; if count == len(sentence) &#123; count = 0 res += 1 &#125; if left &lt; len(sentence[count]) &#123; left = cols break &#125;else if left == len(sentence[count]) &#123; count++ left = cols break &#125; left -= len(sentence[count]) + 1 count++ &#125; &#125; if count == len(sentence) &#123; count = 0 res += 1 &#125; return res&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode 416: Partition Equal Subset Sum]]></title>
    <url>%2F2018%2F10%2F02%2FLeetcode-416-Partition-Equal-Subset-Sum%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920func canPartition(nums []int) bool &#123; var sum, target int for _, v := range nums &#123; sum += v &#125; if sum % 2 == 1 &#123; return false &#125;else &#123; target = sum &gt;&gt; 1 &#125; dp := make([]bool, target + 1) dp[0] = true for _, n := range nums &#123; for i := target; i &gt;= n; i-- &#123; dp[i] = dp[i] || dp[i - n] &#125; &#125; return dp[target] &#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[General Notes of Golang]]></title>
    <url>%2F2018%2F09%2F28%2FGeneral-Notes-of-Golang%2F</url>
    <content type="text"></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 375: Guess Number Higher or Lower II]]></title>
    <url>%2F2018%2F09%2F28%2FLeetCode-375-Guess-Number-Higher-or-Lower-II%2F</url>
    <content type="text"><![CDATA[1234567func getMoneyAmount(n int) int &#123; m := make([][]int, n + 1) for t := range m &#123; m[t] = make([]int, n + 1) &#125; return guessMoney(1, n, m)&#125; 123456789101112131415161718192021222324func guessMoney(start, end int, m [][]int) int &#123; if start &gt;= end &#123; return 0 &#125; if m[start][end] &gt; 0 &#123; return m[start][end] &#125; res := 0x7FFFFFFF for i := start; i &lt; end; i++ &#123; a := guessMoney(start, i - 1, m) b := guessMoney(i + 1, end, m) if a &gt; b &#123; if i + a &lt; res &#123; res = i + a &#125; &#125;else &#123; if i + b &lt; res &#123; res = i + b &#125; &#125; &#125; m[start][end] = res return res&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
        <tag>Minimax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 304: Range Sum Query 2D - Immutable]]></title>
    <url>%2F2018%2F09%2F28%2FLeetCode-304-Range-Sum-Query-2D-Immutable%2F</url>
    <content type="text"><![CDATA[123type NumMatrix struct &#123; dp [][]int&#125; 12345678910111213141516171819202122func Constructor(matrix [][]int) NumMatrix &#123; var m, n int if len(matrix) == 0 || len(matrix[0]) == 0 &#123; m, n = 0, 0 &#125;else &#123; m, n = len(matrix), len(matrix[0]) &#125; dp := make([][]int, m + 1) for v := range dp &#123; dp[v] = make([]int, n + 1) &#125; for i := 1; i &lt;= m; i++ &#123; for j := 1; j &lt;=n; j++ &#123; dp[i][j] = matrix[i-1][j-1] + dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1] &#125; &#125; return NumMatrix&#123;dp: dp&#125;&#125;func (this *NumMatrix) SumRegion(row1 int, col1 int, row2 int, col2 int) int &#123; return this.dp[row2+1][col2+1] - this.dp[row2+1][col1] - this.dp[row1][col2+1] + this.dp[row1][col1]&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 221: Maximal Square]]></title>
    <url>%2F2018%2F09%2F28%2FLeetCode-221-Maximal-Square%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435func maximalSquare(matrix [][]byte) int &#123; if len(matrix) == 0 || len(matrix[0]) == 0 &#123; return 0 &#125; res := 0 dp := make([][]int, len(matrix)) for t := range dp &#123; dp[t] = make([]int, len(matrix[0])) &#125; for i := range matrix &#123; for j := range matrix[i] &#123; if i == 0 || j == 0 &#123; dp[i][j] = int(matrix[i][j]) - '0' &#125;else if int(matrix[i][j]) == '1' &#123; if dp[i-1][j] &lt; dp[i][j-1] &#123; if dp[i-1][j] &lt; dp[i-1][j-1] &#123; dp [i][j] = dp[i-1][j] + 1 &#125;else &#123; dp[i][j] = dp[i-1][j-1] + 1 &#125; &#125;else &#123; if dp[i][j-1] &lt; dp[i-1][j-1] &#123; dp [i][j] = dp[i][j-1] + 1 &#125;else &#123; dp[i][j] = dp[i-1][j-1] + 1 &#125; &#125; &#125; if res &lt; dp[i][j] &#123; res = dp[i][j] &#125; &#125; &#125; return res * res &#125; 1234567891011121314151617181920212223242526272829303132333435func maximalSquare(matrix [][]byte) int &#123; if len(matrix) == 0 || len(matrix[0]) == 0 &#123; return 0 &#125; dp := [2][]int&#123;make([]int, len(matrix[0])+1), make([]int, len(matrix[0])+1)&#125; res, curr := 0, 0 for i := range matrix &#123; prev := curr curr = 1 - curr for j := range matrix[i] &#123; if matrix[i][j] == '0' &#123; dp[curr][j+1] = 0 continue &#125; if dp[curr][j] &lt; dp[prev][j] &#123; if dp[curr][j] &lt; dp[prev][j+1] &#123; dp[curr][j+1] = dp[curr][j] + 1 &#125;else &#123; dp[curr][j+1] = dp[prev][j+1] + 1 &#125; &#125;else &#123; if dp[prev][j] &lt; dp[prev][j+1] &#123; dp[curr][j+1] = dp[prev][j] + 1 &#125;else &#123; dp[curr][j+1] = dp[prev][j+1] + 1 &#125; &#125; if res &lt; dp[curr][j+1] &#123; res = dp[curr][j+1] &#125; &#125; &#125; return res * res&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 198: House Robber]]></title>
    <url>%2F2018%2F09%2F28%2FLeetCode-198-House-Robber%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324func rob(nums []int) int &#123; var even, odd, res int for i, v := range nums &#123; if i % 2 == 0 &#123; if even + v &gt; odd &#123; even = even + v &#125;else &#123; even = odd &#125; &#125;else &#123; if odd + v &gt; even &#123; odd = odd + v &#125;else &#123; odd = even &#125; &#125; &#125; if even &gt; odd &#123; res = even &#125;else &#123; res = odd &#125; return res&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 188: Best Time to Buy and Sell Stock IV]]></title>
    <url>%2F2018%2F09%2F28%2FLeetCode-188-Best-Time-to-Buy-and-Sell-Stock-IV%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122func maxProfit(k int, prices []int) int &#123; if k &gt; len(prices) &#123; k = len(prices) &#125; var bp, sp []int for i := 0; i &lt; k; i++ &#123; bp = append(bp, -0x80000000) sp = append(sp, 0) &#125; sp = append(sp, 0) for _, v := range prices &#123; for j := 0; j &lt; k; j++ &#123; if bp[i] &lt; sp[i] - v &#123; bp[i] = sp[i] - v &#125; if sp[i+1] &lt; v + bp[i] &#123; sp[i+1] = v + bp[i] &#125; &#125; &#125; return sp[k]&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 139: Word Break]]></title>
    <url>%2F2018%2F09%2F28%2FLeetCode-139-Word-Break%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526func wordBreak(s string, wordDict []string) bool &#123; if len(wordDict) == 0 &#123; return false &#125; dict := make(map[string]bool) length := []int for _, v := range wordDict &#123; if _, exist := dict[v]; !exist &#123; dict[v] = true length = append(length,len(v)) &#125; &#125; dp := make([]bool, len(s)+1) dp[0] = true for i := 0; i &lt; len(s); i++ &#123; if !dp[i] &#123; continue &#125; for _, size := range length &#123; dp[i+size] = dp[i+size] || dict[s[i:i+size]] &#125; &#125; return dp[len(s)]&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 10: Regular Expression Matching]]></title>
    <url>%2F2018%2F09%2F28%2FLeetCode-10-Regular-Expression-Matching%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819func isMatch(s string, p string) bool &#123; dp := make([][]bool, len(s)+1) for i := range dp &#123; dp[i] = make([]bool, len(p)+1) &#125; dp[len(s)][len(p)] = true for i := len(s); i &gt;= 0; i-- &#123; for j := len(p) - 1; j &gt;= 0; j-- &#123; firstMatch := i &lt; len(s) &amp;&amp; (p[j] == s[i] || p[j] == '.') if j+1 &lt; len(p) &amp;&amp; p[j + 1] == '*' &#123; dp[i][j] = dp[i][j + 2] || firstMatch &amp;&amp; dp[i + 1][j] &#125;else &#123; dp[i][j] = firstMatch &amp;&amp; dp[i + 1][j + 1] &#125; &#125; &#125; return dp[0][0]&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 8: String to Integer (atoi)]]></title>
    <url>%2F2018%2F09%2F28%2FLeetCode-8-String-to-Integer-atoi%2F</url>
    <content type="text"><![CDATA[This is following: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748func myAtoi(str string) int &#123; s := strings.TrimSpace(str) if len(s) == 0 &#123; return 0 &#125; symbol := ‘+’ if s[0] == ‘-’ &#123; symbol = ‘-’ s = s[1:] &#125;else s[0] == ‘+’ &#123; s = s[1:] &#125; if len(s) == 0 &#123; return 0 &#125; if s[0] &lt; ‘0’ || s[0] &gt; ‘9’ &#123; return 0 &#125; for i := range s &#123; if s[i] &lt; ‘0’ || s[i] &gt; ‘9’ &#123; s = s[:i] break &#125; &#125; res := 0 for _, ch := range []byte(s) &#123; ch -= ‘0’ if ch &gt; 9 &#123; return 0 &#125; res = res*10 + int(ch) if res &gt; 0x7FFFFFFF &#123; if symbol == ‘-’ &#123; return -0x80000000 &#125; return 0x7FFFFFFF &#125; &#125; if symbol == ‘-’ &#123; res = -res &#125; return res&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 7: Reverse Integer]]></title>
    <url>%2F2018%2F09%2F28%2FLeetCode-7-Reverse-Integer%2F</url>
    <content type="text"><![CDATA[1234567891011121314func reverse(x int) int &#123; res := 0 for &#123; res = res * 10 + x % 10 if x / 10 == 0 &#123; break &#125; x = x / 10 &#125; if x &lt; -0x80000000 || x &gt; 0x7FFFFFFF &#123; return 0 &#125; return res&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 5: Longest Palindromic Substring]]></title>
    <url>%2F2018%2F09%2F28%2FLeetCode-5-Longest-Palindromic-Substring%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526func longestPalindrome(s string) string &#123; if len(s) &lt; 2 &#123; return s &#125; index, max := 0, 0 for i := 0; i &lt; len(s) &#123; if len(s) - i &gt; max / 2 &#123; break &#125; begin, end := i, i for end &lt; len(s) - 1 &amp;&amp; s[i] == s[i+1] &#123; end++ &#125; i = end + 1 for end &lt; len(s) - 1 &amp;&amp; begin &gt; 0 &amp;&amp; s[end+1] == s[begin-1] &#123; end++ begin-- &#125; length := end - begin + 1 if max &lt; length &#123; max = length index = begin &#125; &#125; return s[index: index + max]&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 3: Longest Substring Without Repeating Characters]]></title>
    <url>%2F2018%2F09%2F28%2FLeetCode-3-Longest-Substring-Without-Repeating-Characters%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021func lengthOfLongestSubstring(s string) int &#123; m := make(map[uint8]int) res := 0 start, end := 0, 0 for end &lt; len(s) &#123; if p, exist := m[s[end]]; exist &#123; start = p + 1 end = start for k, _ := range m &#123; delete(m, k) &#125; &#125;else &#123; m[s[end]] = end if end - start + 1 &gt; res &#123; res = end - start + 1 &#125; end++ &#125; &#125; return res&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Hash Table</tag>
        <tag>String</tag>
        <tag>Two Pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 2: Add Two Numbers]]></title>
    <url>%2F2018%2F09%2F28%2FLeetCode-2-Add-Two-Numbers%2F</url>
    <content type="text"><![CDATA[1234type ListNode struct &#123; Val interface&#123;&#125; Next *ListNode&#125; 123456789101112131415161718192021func addTwoNumbers(a, b *ListNode) *ListNode &#123; head := new(ListNode) node := head carray := 0 for a != nil || b != nil || carray != 0 &#123; sum := carry if a != nil &#123; sum += a.Val a = a.Next &#125; if b != nil &#123; sum += b.Val b = b.Next &#125; carry = sum / 10 node.Next = new(ListNode) node.Next.Val = sum % 10 node = node.Next &#125; return head.Next&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 1: Two Sum]]></title>
    <url>%2F2018%2F09%2F27%2FLeetCode-1-Two-Sum%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617func twoSum(nums []int, target int) []int &#123; var res []int m := make(map[int]int) for i := 0; i &lt; len(nums); i++ &#123; if v,exist := m[target-nums[i]];exist &#123; if v &lt; i &#123; res = append(res,v,i) &#125;else &#123; res = append(res,i,v) &#125; break &#125;else &#123; m[nums[i]] = i &#125; &#125; return res&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Hash Table</tag>
      </tags>
  </entry>
</search>
