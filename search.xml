<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LeetCode 27: Remove Element]]></title>
    <url>%2F2019%2F06%2F15%2FLeetCode-27-Remove-Element%2F</url>
    <content type="text"><![CDATA[Given an array nums and a value val, remove all instances of that value in-place and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. The order of elements can be changed. It doesn’t matter what you leave beyond the new length.Example 1: Given nums = [3,2,2,3], val = 3, Your function should return length = 2, with the first two elements of nums being 2. It doesn’t matter what you leave beyond the returned length. Example 2: Given nums = [0,1,2,2,3,0,4,2], val = 2, Your function should return length = 5, with the first five elements of nums containing 0, 1, 3, 0, and 4. Note that the order of those five elements can be arbitrary. It doesn’t matter what values are set beyond the returned length. Clarification: Confused why the returned value is an integer but your answer is an array? Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well. Internally you can think of this: // nums is passed in by reference. (i.e., without making a copy)int len = removeElement(nums, val); // any modification to nums in your function would be known by the caller.// using the length returned by your function, it prints the first len elements.for (int i = 0; i &lt; len; i++) { print(nums[i]);} 1234567public int removeElement(int[] nums, int val) &#123; int res = 0; for (int i : nums) &#123; if (i != val) nums[res++] = i; &#125; return res;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Amazon</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 23: Merge k Sorted Lists]]></title>
    <url>%2F2019%2F06%2F15%2FLeetCode-23-Merge-k-Sorted-Lists%2F</url>
    <content type="text"><![CDATA[Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity. Example:Input:[ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6]Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6 1234567891011121314151617181920212223242526public ListNode mergeKLists(ListNode[] lists) &#123; if(lists==null||lists.length==0) return null; PriorityQueue&lt;ListNode&gt; queue = new PriorityQueue&lt;ListNode&gt;(new Comparator&lt;ListNode&gt;()&#123; public int compare(ListNode l1, ListNode l2)&#123; return l1.val - l2.val; &#125; &#125;); ListNode head = new ListNode(-1); ListNode p = head; for(ListNode list: lists)&#123; if(list!=null) queue.offer(list); &#125; while(!queue.isEmpty())&#123; ListNode n = queue.poll(); p.next = n; p=p.next; if(n.next!=null) queue.offer(n.next); &#125; return head.next; &#125;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Amazon</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 5: Longest Palindromic Substring]]></title>
    <url>%2F2019%2F06%2F15%2FLeetCode-5-Longest-Palindromic-Substring-1%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Password Test]]></title>
    <url>%2F2019%2F06%2F15%2FPassword-Test%2F</url>
    <content type="text"><![CDATA[Welcome to my blog, enter password to read. Incorrect Password! No content to display! U2FsdGVkX19lTEZBtJBqBsuL7cdFa1fnFca4bRxskbRu6cmQ1pyrNa8aKVS5IDwAcE1LGjlsKQkd/yq5ipz/v/Z9kK8fog1RVXkLZ1/cSYq7cjrH9R6dpLkPqjBEoAuRgponZlvCoQHhZmyA/fFT7yGFF6/ZaaqJIswa7OCZpf0apVhtpCLVI3XaO/zSQDTKcn+gsBCG50qCZgkEIjjxoj+WVqseJbIVmY+RdVzHw7/y/WAHjT8j9+hSjajXUlVY]]></content>
      <categories>
        <category>Test</category>
      </categories>
      <tags>
        <tag>Test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 4: Median of Two Sorted Arrays]]></title>
    <url>%2F2018%2F10%2F17%2FLeetCode-4-Median-of-Two-Sorted-Arrays%2F</url>
    <content type="text"><![CDATA[There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). You may assume nums1 and nums2 cannot be both empty.Example 1:nums1 = [1, 3]nums2 = [2] The median is 2.0 Example 2:nums1 = [1, 2]nums2 = [3, 4] The median is (2 + 3)/2 = 2.5 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123; int n1 = nums1.length; int n2 = nums2.length; if (n1 &gt; n2) &#123; return findMedianSortedArrays(nums2, nums1); &#125; int k = (n1 + n2 + 1)/2; int left = 0; int right = n1; while(left &lt; right)&#123; int m1 = left + (right - left)/2; int m2 = k - m1; if (nums1[m1] &lt; nums2[m2-1]) &#123; left = m1 + 1; &#125;else &#123; right = m1; &#125; &#125; int m1 = left; int m2 = k - left; int c1 = Math.max(m1 &lt;= 0 ? Integer.MIN_VALUE : nums1[m1-1], m2 &lt;= 0 ? Integer.MIN_VALUE : nums2[m2-1]); if ((n1 + n2) % 2 == 1) &#123; return c1; &#125; int c2 = Math.min( m1 &gt;= n1 ? Integer.MAX_VALUE :nums1[m1], m2 &gt;= n2 ? Integer.MAX_VALUE : nums2[m2]); return (c1 + c2) * 0.5;&#125;``` ``` gofunc findMedianSortedArrays(nums1 []int, nums2 []int) float64 &#123; n1 := len(nums1) n2 := len(nums2) if n1 &lt; n2 &#123; return findMedianSortedArrays(nums2, nums1) &#125; lo, hi := 0, n2 * 2 for lo &lt;= hi &#123; mid2 := (lo + hi) &gt;&gt; 1 mid1 := n1 + n2 - mid2 var l1, l2, r1, r2 int if mid1 == 0 &#123; l1 = ^(int(^uint(0) &gt;&gt; 1)) &#125;else &#123; l1 = nums1[(mid1-1)/2] &#125; if mid2 == 0 &#123; l2 = ^(int(^uint(0) &gt;&gt; 1)) &#125;else &#123; l2 = nums2[(mid2-1)/2] &#125; if mid1 == n1 * 2 &#123; r1 = int(^uint(0) &gt;&gt; 1) &#125;else &#123; r1 = nums1[mid1/2] &#125; if mid2 == n2 * 2 &#123; r2 = int(^uint(0) &gt;&gt; 1) &#125;else &#123; r2 = nums2[mid2/2] &#125; if l1 &gt; r2 &#123; lo = mid2 + 1 &#125;else if l2 &gt; r1 &#123; hi = mid2 - 1 &#125;else &#123; var max, min int if l1 &lt; l2 &#123; max = l2 &#125;else &#123; max = l1 &#125; if r1 &lt; r2 &#123; min = r1 &#125;else &#123; min = r2 &#125; res := float64(max + min) / 2.0 return res &#125; &#125; return float64(-1)&#125;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Amazon</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Binary Search</tag>
        <tag>Divide and Conquer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 346: Moving Average from Data Stream]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-346-Moving-Average-from-Data-Stream%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 486: Predict the Winner]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-486-Predict-the-Winner%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 734: Sentence Similarity]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-734-Sentence-Similarity%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 307: Range Sum Query - Mutable]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-307-Range-Sum-Query-Mutable%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 447: Number of Boomerangs]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-447-Number-of-Boomerangs%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 776: Split BST]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-776-Split-BST%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 424: Longest Repeating Character Replacement]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-424-Longest-Repeating-Character-Replacement%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 457: Circular Array Loop]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-457-Circular-Array-Loop%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 766: Toeplitz Matrix]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-766-Toeplitz-Matrix%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 849: Maximize Distance to Closest Person]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-849-Maximize-Distance-to-Closest-Person%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 731: My Calendar II]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-731-My-Calendar-II%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 846: Hand of Straights]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-846-Hand-of-Straights%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 205: Isomorphic Strings]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-205-Isomorphic-Strings%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 833: Find And Replace in String]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-833-Find-And-Replace-in-String%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 562: Longest Line of Consecutive One in Matrix]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-562-Longest-Line-of-Consecutive-One-in-Matrix%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 299: Bulls and Cows]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-299-Bulls-and-Cows%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 686: Repeated String Match]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-686-Repeated-String-Match%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 904: Fruit Into Baskets]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-904-Fruit-Into-Baskets%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 844: Backspace String Compare]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-844-Backspace-String-Compare%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 482: License Key Formatting]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-482-License-Key-Formatting%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 681: Next Closest Time]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-681-Next-Closest-Time%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 91: Decode Ways]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-91-Decode-Ways%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 80: Remove Duplicates from Sorted Array II]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-80-Remove-Duplicates-from-Sorted-Array-II%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 76: Minimum Window Substring]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-76-Minimum-Window-Substring%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 75: Sort Colors]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-75-Sort-Colors%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 72: Edit Distance]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-72-Edit-Distance%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 70: Climbing Stairs]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-70-Climbing-Stairs%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 69: Sqrt(x)]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-69-Sqrt-x%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 66: Plus One]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-66-Plus-One%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 62: Unique Paths]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-62-Unique-Paths%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 60: Permutation Sequence]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-60-Permutation-Sequence%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 56: Merge Intervals]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-56-Merge-Intervals%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 54: Spiral Matrix]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-54-Spiral-Matrix%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 50: Pow(x, n)]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-50-Pow-x-n%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 49: Group Anagrams]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-49-Group-Anagrams%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 48: Rotate Image]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-48-Rotate-Image%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 43: Multiply Strings]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-43-Multiply-Strings%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 38: Count and Say]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-38-Count-and-Say%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 36: Valid Sudoku]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-36-Valid-Sudoku%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 35: Search Insert Position]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-35-Search-Insert-Position%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 34: Find First and Last Position of Element in Sorted Array]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-34-Find-First-and-Last-Position-of-Element-in-Sorted-Array%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 33: Search in Rotated Sorted Array]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-33-Search-in-Rotated-Sorted-Array%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 31: Next Permutation]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-31-Next-Permutation%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 26: Remove Duplicates from Sorted Array]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-26-Remove-Duplicates-from-Sorted-Array%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 20: Valid Parentheses]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-20-Valid-Parentheses%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 15: 3Sum]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-15-3Sum%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 14: Longest Common Prefix]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-14-Longest-Common-Prefix%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 13: Roman to Integer]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-13-Roman-to-Integer%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 11: Container With Most Water]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-11-Container-With-Most-Water%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 6: ZigZag Conversion]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-6-ZigZag-Conversion%2F</url>
    <content type="text"><![CDATA[The string “PAYPALISHIRING” is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)P&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;&nbsp;&nbsp;&nbsp;H&nbsp;&nbsp;&nbsp;&nbsp;NA&nbsp;P&nbsp;L&nbsp;S&nbsp;I&nbsp;&nbsp;I&nbsp;&nbsp;GY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;I&nbsp;&nbsp;&nbsp;&nbsp;RAnd then read line by line: “PAHNAPLSIIGYIR” Write the code that will take a string and make this conversion given a number of rows: string convert(string s, int numRows); Example 1:Input: s = “PAYPALISHIRING”, numRows = 3Output: “PAHNAPLSIIGYIR” Example 2:Input: s = “PAYPALISHIRING”, numRows = 4Output: “PINALSIGYAHRPI”Explanation:P&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;I&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NA&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;L&nbsp;&nbsp;S&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;I&nbsp;&nbsp;GY &nbsp;A&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;H&nbsp;&nbsp;RP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;I 123456789101112131415161718192021222324func convert(s string, numRows int) string &#123; if numRows == 1 || len(s) &lt;= numRows &#123; return s &#125; str := strings.Split(s, "") var res []string p := numRows*2 - 2 for i := 0; i &lt; len(str); i += p &#123; res = append(res, str[i]) &#125; for r := 1; r &lt;= numRows-2; r++ &#123; res = append(res, str[r]) for k := p; k-r &lt; len(s); k += p &#123; res = append(res, str[k-r]) if k+r &lt; len(str) &#123; res = append(res, str[k+r]) &#125; &#125; &#125; for i := numRows - 1; i &lt; len(str); i += p &#123; res = append(res, str[i]) &#125; return strings.Join(res, "")&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 78: Subsets]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-78-Subsets%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 46: Permutations]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-46-Permutations%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 22: Generate Parentheses]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-22-Generate-Parentheses%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 17: Letter Combinations of a Phone Number]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-17-Letter-Combinations-of-a-Phone-Number%2F</url>
    <content type="text"><![CDATA[Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters. Example:Input: “23”Output: [“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”]. Note:Although the above answer is in lexicographical order, your answer could be in any order you want. private List&lt;String&gt; res = new ArrayList&lt;String&gt;(); public List&lt;String&gt; letterCombinations(String digits) { if (digits == null || digits.length() == 0) return res; char[] inputs = digits.toCharArray(); dfs(inputs, 0, ""); return res; } public void dfs(char[] inputs, int level, String output) { if (inputs.length == level) { res.add(output); return; } String[] str = dial(inputs[level]); for (int i = 0; i &lt; str.length; i++) { dfs(inputs, level + 1, output + String.valueOf(str[i])); } } public String[] dial(char num) { switch(num) { case '2': return new String[] {"a","b","c"}; case '3': return new String[] {"d","e","f"}; case '4': return new String[] {"g","h","i"}; case '5': return new String[] {"j","k","l"}; case '6': return new String[] {"m","n","o"}; case '7': return new String[] {"p","q","r","s"}; case '8': return new String[] {"t","u","v"}; case '9': return new String[] {"w","x","y","z"}; default: return new String[] {""}; } }]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Amazon</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 785: Is Graph Bipartite?]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-785-Is-Graph-Bipartite%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 684: Redundant Connection]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-684-Redundant-Connection%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 444: Sequence Reconstruction]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-444-Sequence-Reconstruction%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 399: Evaluate Division]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-399-Evaluate-Division%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 310: Minimum Height Trees]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-310-Minimum-Height-Trees%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 210: Course Schedule II]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-210-Course-Schedule-II%2F</url>
    <content type="text"><![CDATA[There are a total of n courses you have to take, labeled from 0 to n-1. Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1] Given the total number of courses and a list of prerequisite pairs, return the ordering of courses you should take to finish all courses. There may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array.Example 1:Input: 2, [[1,0]]Output: [0,1]Explanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1] . Example 2:Input: 4, [[1,0],[2,0],[3,1],[3,2]]Output: [0,1,2,3] or [0,2,1,3]Explanation: There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0. So one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3] . Note: The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented. You may assume that there are no duplicate edges in the input prerequisites. BFS Solution:1234567891011121314151617181920212223242526272829func findOrder(numCourses int, prerequisites [][]int) []int &#123; graph := make([][]int, numCourses) indegree := make([]int, numCourses) var queue, res []int for _, pair := range prerequisites &#123; graph[pair[1]] = append(graph[pair[1]], pair[0]) indegree[pair[0]]++ &#125; for n, v := range indegree &#123; if v == 0 &#123; queue = append(queue, n) &#125; &#125; for len(queue) != 0 &#123; res = append(res, queue[0]) for _, a := range graph[queue[0]] &#123; indegree[a]-- if indegree[a] == 0 &#123; queue = append(queue, a) &#125; &#125; queue = queue[1:] &#125; if len(res) != numCourses &#123; var empty []int return empty &#125; return res&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Breadth-first Search</tag>
        <tag>Depth-first Search</tag>
        <tag>Graph</tag>
        <tag>Topological Sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 207: Course Schedule]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-207-Course-Schedule%2F</url>
    <content type="text"><![CDATA[There are a total of n courses you have to take, labeled from 0 to n-1. Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1] Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?Example 1:Input: 2, [[1,0]]Output: trueExplanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So it is possible. Example 2:Input: 2, [[1,0],[0,1]]Output: falseExplanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible. Note: This problem is equivalent to finding if a cycle exists in a directed graph. If a cycle exists, no topological ordering exists and therefore it will be impossible to take all courses. The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented. Topological Sort via DFS - A great video tutorial (21 minutes) on Coursera explaining the basic concepts of Topological Sort. Topological sort could also be done via BFS. You may assume that there are no duplicate edges in the input prerequisites. BFS Solution:12345678910111213141516171819202122232425262728293031323334func canFinish(numCourses int, prerequisites [][]int) bool &#123; graph := make([][]int, numCourses) indegree := make([]int, numCourses) var queue []int for _, pair := range prerequisites &#123; graph[pair[1]] = append(graph[pair[1]], pair[0]) indegree[pair[0]]++ &#125; for n, v := range indegree &#123; if v == 0 &#123; queue = append(queue, n) &#125; &#125; for len(queue) != 0 &#123; for _, a := range graph[queue[0]] &#123; indegree[a]-- if indegree[a] == 0 &#123; queue = append(queue, a) &#125; &#125; queue = queue[1:] &#125; for i := 0; i &lt; numCourses; i++ &#123; if indegree[i] != 0 &#123; return false &#125; &#125; return true&#125; DFS Solution:123456789101112131415161718192021222324252627282930313233func canFinshDFS(graph [][]int, visit []int, i int) bool &#123; if visit[i] == -1 &#123; return false &#125; if visit[i] == 1 &#123; return true &#125; visit[i] = -1 for _, a := range graph[i] &#123; if !canFinshDFS(graph, visit, a) &#123; return false &#125; &#125; visit[i] = 1 return true&#125;func canFinish(numCourses int, prerequisites [][]int) bool &#123; graph := make([][]int, numCourses) visit := make([]int, numCourses) for _, pair := range prerequisites &#123; graph[pair[1]] = append(graph[pair[1]], pair[0]) &#125; for i := 0; i &lt; numCourses; i++ &#123; if !canFinshDFS(graph, visit, i) &#123; return false &#125; &#125; return true&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Breadth-first Search</tag>
        <tag>Depth-first Search</tag>
        <tag>Graph</tag>
        <tag>Topological Sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 662: Maximum Width of Binary Tree]]></title>
    <url>%2F2018%2F10%2F09%2FLeetCode-662-Maximum-Width-of-Binary-Tree%2F</url>
    <content type="text"><![CDATA[Given a binary tree, write a function to get the maximum width of the given tree. The width of a tree is the maximum width among all levels. The binary tree has the same structure as a full binary tree, but some nodes are null. The width of one level is defined as the length between the end-nodes (the leftmost and right most non-null nodes in the level, where the null nodes between the end-nodes are also counted into the length calculation. Example 1:Input: 1 / \ 3 2 / \ \ 5 3 9 Output: 4Explanation: The maximum width existing in the third level with the length 4 (5,3,null,9). Example 2:Input: 1 / 3 / \ 5 3 Output: 2Explanation: The maximum width existing in the third level with the length 2 (5,3). Example 3:Input: 1 / \ 3 2 / 5 Output: 2Explanation: The maximum width existing in the second level with the length 2 (3,2). Example 4:Input: 1 / \ 3 2 / \ 5 9 / \ 6 7 Output: 8Explanation:The maximum width existing in the fourth level with the length 8 (6,null,null,null,null,null,null,7). Note: Answer will in the range of 32-bit signed integer. 12345type TreeNode struct &#123; Val int Left *TreeNode Right *TreeNode&#125; 1234567891011121314151617181920func widthOfTree(root *TreeNode, depth, idx int, start *[]int) int &#123; if root == nil &#123; return 0 &#125; if depth &gt;= len(*start) &#123; *start = append(*start, idx) &#125; res := idx - (*start)[depth] + 1 left := widthOfTree(root.Left, depth + 1, idx * 2, start) right := widthOfTree(root.Right, depth + 1, idx * 2 + 1, start) if left &lt; right &#123; left = right &#125; if res &lt; left &#123; res = left &#125; return res&#125; 1234func widthOfBinaryTree(root *TreeNode) int &#123; var start []int return widthOfTree(root, 0, 1, &amp;start)&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 872: Leaf-Similar Trees]]></title>
    <url>%2F2018%2F10%2F09%2FLeetCode-872-Leaf-Similar-Trees%2F</url>
    <content type="text"><![CDATA[Consider all the leaves of a binary tree. From left to right order, the values of those leaves form a leaf value sequence. For example, in the given tree above, the leaf value sequence is (6, 7, 4, 9, 8). Two binary trees are considered leaf-similar if their leaf value sequence is the same. Return true if and only if the two given trees with head nodes root1 and root2 are leaf-similar. Note: Both of the given trees will have between 1 and 100 nodes.12345type TreeNode struct &#123; Val int Left *TreeNode Right *TreeNode&#125; 123456789func getLeaves(node *TreeNode) []int &#123; if node == nil &#123; return nil &#125; if node.Left == nil &amp;&amp; node.Right == nil &#123; return []int&#123;node.Val&#125; &#125; return append(getLeaves(node.Left), getLeaves(node.Right)...)&#125; 12345678910111213func leafSimilar(root1 *TreeNode, root2 *TreeNode) bool &#123; vals1 := getLeaves(root1) vals2 := getLeaves(root2) if len(vals1) != len(vals2) &#123; return false &#125; for i:=0; i&lt;len(vals1); i++ &#123; if vals1[i] != vals2[i] &#123; return false &#125; &#125; return true&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Tree</tag>
        <tag>Depth-first Search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 742: Closest Leaf in a Binary Tree]]></title>
    <url>%2F2018%2F10%2F09%2FLeetCode-742-Closest-Leaf-in-a-Binary-Tree%2F</url>
    <content type="text"><![CDATA[Given a binary tree where every node has a unique value, and a target key k, find the value of the nearest leaf node to target k in the tree. Here, nearest to a leaf means the least number of edges travelled on the binary tree to reach any leaf of the tree. Also, a node is called a leaf if it has no children. In the following examples, the input tree is represented in flattened form row by row. The actual root tree given will be a TreeNode object. Example 1:Input:root = [1, 3, 2], k = 1Diagram of binary tree: 1 / \ 3 2 Output: 2 (or 3)Explanation: Either 2 or 3 is the nearest leaf node to the target of 1. Example 2:Input:root = [1], k = 1Output: 1Explanation: The nearest leaf node is the root node itself. Example 3:Input:root = [1,2,3,4,null,null,null,5,null,6], k = 2Diagram of binary tree: 1 / \ 2 3 / 4 / 5 / 6 Output: 3Explanation: The leaf node with value 3 (and not the leaf node with value 6) is nearest to the node with value 2. Note: root represents a binary tree with at least 1 node and at most 1000 nodes. Every node has a unique node.val in range [1, 1000]. There exists some node in the given binary tree for which node.val == k. 12345type TreeNode struct &#123; Val int Left *TreeNode Right *TreeNode&#125; 1234type Record struct &#123; m map[*TreeNode]*TreeNode&#125;var back Record 1234567891011121314151617181920func find(root *TreeNode, k int) *TreeNode &#123; if root.Val == k &#123; return root &#125; if root.Left != nil &#123; back.m[root.Left.Val] = root left := find(root.Left, k) if left != nil &#123; return left &#125; &#125; if root.Right != nil &#123; back.m[root.Right.Val] = root right := find(root.Right, k) if right != nil &#123; return right &#125; &#125; return nil&#125; 12345678910111213141516171819202122232425262728293031func findClosestLeaf(root *TreeNode, k int) int &#123; back.m = make(map[int]*TreeNode) visited := make(map[int]*TreeNode) kNode := find(root, k) var q []*TreeNode q = append(q, kNode) visited[kNode.Val] = kNode for len(q) != 0 &#123; for _, v := range q &#123; if v.Left == nil &amp;&amp; v.Right == nil &#123; return v.Val &#125; if v.Left != nil &#123; visited[v.Left.Val] = v.Left q = append(q, v.Left) &#125; if v.Right != nil &#123; visited[v.Right.Val] = v.Right q = append(q, v.Right) &#125; _, isBack := back.m[v.Val] _, isVisited := visited[v.Val] if isBack &amp;&amp; !isVisited &#123; visited[v.Val] = v q = append(q, back.m[v.Val]) &#125; q = q[1:] &#125; &#125; return -1&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Tree</tag>
        <tag>Not solved</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 687: Longest Univalue Path]]></title>
    <url>%2F2018%2F10%2F09%2FLeetCode-687-Longest-Univalue-Path%2F</url>
    <content type="text"><![CDATA[Given a binary tree, find the length of the longest path where each node in the path has the same value. This path may or may not pass through the root. Note: The length of path between two nodes is represented by the number of edges between them. Example 1:Input: 5 / \ 4 5 / \ \ 1 1 5 Output: 2 Example 2:Input: 1 / \ 4 5 / \ \ 4 4 5 Output: 2 Note: The given binary tree has not more than 10000 nodes. The height of the tree is not more than 1000. 12345type TreeNode struct &#123; Val int Left *TreeNode Right *TreeNode&#125; 1234567891011121314151617181920212223242526272829func longestPath(root, parent *TreeNode, res *int) int &#123; if root == nil &#123; return 0 &#125; left := longestPath(root.Left, root, res) right := longestPath(root.Right, root, res) if root.Left != nil &amp;&amp; root.Val == root.Left.Val &#123; left++ &#125;else &#123; left = 0 &#125; if root.Right != nil &amp;&amp; root.Val == root.Right.Val &#123; right++ &#125;else &#123; right = 0 &#125; if *res &lt; left + right &#123; *res = left + right &#125; if left &lt; right &#123; left = right &#125; return left&#125; 12345678func longestUnivaluePath(root *TreeNode) int &#123; if root == nil &#123; return 0 &#125; res := 0 longestPath(root, root, &amp;res) return res&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Tree</tag>
        <tag>Recursion</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 653: Two Sum IV - Input is a BST]]></title>
    <url>%2F2018%2F10%2F09%2FLeetCode-653-Two-Sum-IV-Input-is-a-BST%2F</url>
    <content type="text"><![CDATA[Given a Binary Search Tree and a target number, return true if there exist two elements in the BST such that their sum is equal to the given target. Example 1:Input: 5 / \ 3 6 / \ \ 2 4 7 Target = 9Output: True Example 2:Input: 5 / \ 3 6 / \ \ 2 4 7 Target = 28Output: False 12345type TreeNode struct &#123; Val int Left *TreeNode Right *TreeNode&#125; 12345678910111213141516171819202122232425func findTarget(root *TreeNode, k int) bool &#123; if root == nil &#123; return false &#125; var queue []*TreeNode queue = append(queue, root) m := make(map[int]int) for len(queue) != 0 &#123; for _, v := range queue &#123; if v.Left != nil &#123; queue = append(queue, v.Left) &#125; if v.Right != nil &#123; queue = append(queue, v.Right) &#125; if _, exist := m[v.Val]; exist &#123; return true &#125;else &#123; m[k-v.Val] = v.Val &#125; queue = queue[1:] &#125; &#125; return false&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 652: Find Duplicate Subtrees]]></title>
    <url>%2F2018%2F10%2F09%2FLeetCode-652-Find-Duplicate-Subtrees%2F</url>
    <content type="text"><![CDATA[Given a binary tree, return all duplicate subtrees. For each kind of duplicate subtrees, you only need to return the root node of any one of them. Two trees are duplicate if they have the same structure with same node values. Example 1: 1 / \ 2 3 / / \ 4 2 4 / 4 The following are two duplicate subtrees: 2 / 4 and 4 Therefore, you need to return above trees’ root in the form of a list. 12345type TreeNode struct &#123; Val int Left *TreeNode Right *TreeNode&#125; 1234type Record struct &#123; m map[string]int&#125;var rec Record 12345678910111213141516func findDuplicate(root *TreeNode, res *[]*TreeNode) string &#123; if root == nil &#123; return "#" &#125; str := string(root.Val) + "," + findDuplicate(root.Left, res) + "," + findDuplicate(root.Right, res) if _, exist := rec.m[str]; exist &#123; if rec.m[str] == 1 &#123; *res = append(*res, root) &#125; rec.m[str]++ &#125;else &#123; rec.m[str] = 1 &#125; return str&#125; 123456func findDuplicateSubtrees(root *TreeNode) []*TreeNode &#123; var res []*TreeNode rec.m = make(map[string]int) findDuplicate(root, &amp;res) return res&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Tree</tag>
        <tag>Not solved</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 572: Subtree of Another Tree]]></title>
    <url>%2F2018%2F10%2F09%2FLeetCode-572-Subtree-of-Another-Tree%2F</url>
    <content type="text"><![CDATA[Given two non-empty binary trees s and t, check whether tree t has exactly the same structure and node values with a subtree of s. A subtree of s is a tree consists of a node in s and all of this node’s descendants. The tree s could also be considered as a subtree of itself. Example 1:Given tree s: 3 / \ 4 5 / \ 1 2 Given tree t: 4 / \ 1 2 Return true, because t has the same structure and node values with a subtree of s. Example 2:Given tree s: 3 / \ 4 5 / \ 1 2 / 0 Given tree t: 4 / \ 1 2 Return false. 12345type TreeNode struct &#123; Val int Left *TreeNode Right *TreeNode&#125; 123456789func equal(s, t *TreeNode) bool &#123; if s == nil &amp;&amp; t == nil &#123; return true &#125; if s == nil || t == nil || s.Val != t.Val &#123; return false &#125; return equal(s.Left, t.Left) &amp;&amp; equal(s.Right, t.Right)&#125; 123456789101112func isSubtree(s *TreeNode, t *TreeNode) bool &#123; if t == nil &#123; return true &#125; if s == nil &amp;&amp; t != nil &#123; return false &#125; if equal(s, t) &#123; return true &#125; return isSubtree(s.Left, t) || isSubtree(s.Right, t)&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 549: Binary Tree Longest Consecutive Sequence II]]></title>
    <url>%2F2018%2F10%2F09%2FLeetCode-549-Binary-Tree-Longest-Consecutive-Sequence-II%2F</url>
    <content type="text"><![CDATA[Given a binary tree, you need to find the length of Longest Consecutive Path in Binary Tree. Especially, this path can be either increasing or decreasing. For example, [1,2,3,4] and [4,3,2,1] are both considered valid, but the path [1,2,4,3] is not valid. On the other hand, the path can be in the child-Parent-child order, where not necessarily be parent-child order. Example 1:Input: 1 / \ 2 3 Output: 2Explanation: The longest consecutive path is [1, 2] or [2, 1]. Example 2:Input: 2 / \ 1 3 Output: 3Explanation: The longest consecutive path is [1, 2, 3] or [3, 2, 1]. Note: All the values of tree nodes are in the range of [-1e7, 1e7]. 12345type TreeNode struct &#123; Val int Left *TreeNode Right *TreeNode&#125; 12345678910111213141516func currentLongest(root *TreeNode, diff int) int &#123; if root == nil &#123; return 0 &#125; left, right := 0, 0 if root.Left != nil &amp;&amp; root.Val - root.Left.Val == diff &#123; left = 1 + currentLongest(root.Left, diff) &#125; if root.Right != nil &amp;&amp; root.Val - root.Right.Val == diff &#123; right = 1 + currentLongest(root.Right, diff) &#125; if left &lt; right &#123; left = right &#125; return left&#125; 123456789101112131415161718func longestConsecutive(root *TreeNode) int &#123; if root == nil &#123; return 0 &#125; res := currentLongest(root, 1) + currentLongest(root, -1) + 1 left := longestConsecutive(root.Left) right := longestConsecutive(root.Right) if left &gt; right &#123; if left &gt; res &#123; res = left &#125; &#125;else &#123; if right &gt; res &#123; res = right &#125; &#125; return res&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 543: Diameter of Binary Tree]]></title>
    <url>%2F2018%2F10%2F09%2FLeetCode-543-Diameter-of-Binary-Tree%2F</url>
    <content type="text"><![CDATA[Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root. Example:Given a binary tree 1 / \ 2 3 / \ 4 5 Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3]. Note: The length of path between two nodes is represented by the number of edges between them. 12345type TreeNode struct &#123; Val int Left *TreeNode Right *TreeNode&#125; 12345678910111213141516func maxDepth(root *TreeNode, res *int) int &#123; if root == nil &#123; return 0 &#125; left := maxDepth(root.Left, res) right := maxDepth(root.Right, res) if left + right &gt; *res &#123; *res = left + right &#125; if left &lt; right &#123; left = right &#125; return left + 1&#125; 12345func diameterOfBinaryTree(root *TreeNode) int &#123; res := 0 maxDepth(root, &amp;res) return res&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 250: Count Univalue Subtrees]]></title>
    <url>%2F2018%2F10%2F06%2FLeetCode-250-Count-Univalue-Subtrees%2F</url>
    <content type="text"><![CDATA[Given a binary tree, count the number of uni-value subtrees. A Uni-value subtree means all nodes of the subtree have the same value. Example :Input: root = [5,1,5,5,5,null,5] 5 / \ 1 5 / \ \ 5 5 5 Output: 412345type TreeNode struct &#123; Val int Left *TreeNode Right *TreeNode&#125; 1234567891011func dfs(root *TreeNode, val int, res *int) bool &#123; if root == nil &#123; return true &#125; left := dfs(root.Left,root.Val,res) right := dfs(root.Right,root.Val,res) if left &amp;&amp; right &#123; *res++ &#125; return (root.Val == val) &amp;&amp; left &amp;&amp; right&#125; 12345678func countUnivalSubtrees(root *TreeNode) int &#123; res := 0 if root == nil &#123; return res &#125; dfs(root, root.Val, &amp;res) return res&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 226: Invert Binary Tree]]></title>
    <url>%2F2018%2F10%2F06%2FLeetCode-226-Invert-Binary-Tree%2F</url>
    <content type="text"><![CDATA[Invert a binary tree. Example:Input: 4 / \ 2 7 / \ / \ 1 3 6 9 Output: 4 / \ 7 2 / \ / \ 9 6 3 1 12345type TreeNode struct &#123; Val int Left *TreeNode Right *TreeNode&#125; 123456789101112131415func invertTree(root *TreeNode) *TreeNode &#123; if root == nil &#123; return root &#125; var left, right *TreeNode if root.Left != nil &#123; right = invertTree(root.Left) &#125; if root.Right != nil &#123; left = invertTree(root.Right) &#125; root.Left = left root.Right = right return root&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 222: Count Complete Tree Nodes]]></title>
    <url>%2F2018%2F10%2F06%2FLeetCode-222-Count-Complete-Tree-Nodes%2F</url>
    <content type="text"><![CDATA[Given a complete binary tree, count the number of nodes. Note: Definition of a complete binary tree from Wikipedia:In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and $2^h$ nodes inclusive at the last level h. Example:Input: 1 / \ 2 3 / \ / 4 5 6 Output: 6 12345type TreeNode struct &#123; Val int Left *TreeNode Right *TreeNode&#125; 1234567891011121314151617181920func countNodes(root *TreeNode) int &#123; if root == nil &#123; return 0 &#125; res := 0 queue := []*TreeNode&#123;root&#125; for len(queue) != 0 &#123; res = res + len(queue) for _, v := range queue &#123; if v.Left != nil &#123; queue = append(queue, v.Left) &#125; if v.Right != nil &#123; queue = append(queue, v.Right) &#125; queue = queue[1:] &#125; &#125; return res&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Tree</tag>
        <tag>Binary Search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 124: Binary Tree Maximum Path Sum]]></title>
    <url>%2F2018%2F10%2F06%2FLeetCode-124-Binary-Tree-Maximum-Path-Sum%2F</url>
    <content type="text"><![CDATA[Given a non-empty binary tree, find the maximum path sum. For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root. Example 1:Input: [1,2,3] 1 / \ 2 3 Output: 6 Example 2:Input: [-10,9,20,null,null,15,7] -10 / \ 9 20 / \ 15 7 Output: 42 12345type TreeNode struct &#123; Val int Left *TreeNode Right *TreeNode&#125; 123456789101112131415161718192021222324func maxPath(root *TreeNode, res *int) int &#123; if root == nil &#123; return 0 &#125; left := maxPath(root.Left, res) if left &lt; 0 &#123; left = 0 &#125; right := maxPath(root.Right, res) if right &lt; 0 &#123; right = 0 &#125; if left + right + root.Val &gt; *res &#123; *res = left + right + root.Val &#125; if left &lt; right &#123; left = right &#125; return root.Val + left&#125; 12345func maxPathSum(root *TreeNode) int &#123; res := -0x7FFFFFFF maxPath(root, &amp;res) return res&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Tree</tag>
        <tag>Depth-first Search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 110: Balanced Binary Tree]]></title>
    <url>%2F2018%2F10%2F06%2FLeetCode-110-Balanced-Binary-Tree%2F</url>
    <content type="text"><![CDATA[Given a binary tree, determine if it is height-balanced. For this problem, a height-balanced binary tree is defined as: a binary tree in which the depth of the two subtrees of every node never differ by more than 1. Example 1:Given the following tree [3,9,20,null,null,15,7]: 3 / \ 9 20 / \ 15 7 Return true. Example 2:Given the following tree [1,2,2,3,3,null,null,4,4]: 1 / \ 2 2 / \ 3 3 / \ 4 4 Return false. 12345type TreeNode struct &#123; Val int Left *TreeNode Right *TreeNode&#125; 123456789101112131415161718192021func checkDepth(root *TreeNode) int &#123; if root == nil &#123; return 0 &#125; left := checkDepth(root.Left) if left == -1 &#123; return -1 &#125; right := checkDepth(root.Right) if right == -1 &#123; return -1 &#125; if right &gt; left &#123; left, right = right, left &#125; diff := left - right if diff &gt; 1 &#123; return -1 &#125; return 1 + left&#125; 123456func isBalanced(root *TreeNode) bool &#123; if checkDepth(root) == -1 &#123; return false &#125; return true&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Tree</tag>
        <tag>Depth-first Search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 108: Convert Sorted Array to Binary Search Tree]]></title>
    <url>%2F2018%2F10%2F06%2FLeetCode-108-Convert-Sorted-Array-to-Binary-Search-Tree%2F</url>
    <content type="text"><![CDATA[Given an array where elements are sorted in ascending order, convert it to a height balanced BST. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. Example:Given the sorted array: [-10,-3,0,5,9], One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST: 0 / \ -3 9 / / -10 5 12345type TreeNode struct &#123; Val int Left *TreeNode Right *TreeNode&#125; 12345678910111213141516171819func sortedArrayToBST(nums []int) *TreeNode &#123; if len(nums) == 0 &#123; return nil &#125;else if len(nums) == 1 &#123; res1 := &amp;TreeNode&#123;Val: nums[0],Left: nil,Right: nil&#125; return res1 &#125;else if len(nums) == 2 &#123; resNode := &amp;TreeNode&#123;Val: nums[0],Left: nil,Right: nil&#125; res2 := &amp;TreeNode&#123;Val: nums[1],Left: resNode,Right: nil&#125; return res2 &#125; key := len(nums) / 2 left := nums[:key] right := nums[key+1:] res := &amp;TreeNode&#123;Val: nums[key], Left: sortedArrayToBST(left),Right: sortedArrayToBST(right)&#125; return res&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Tree</tag>
        <tag>Depth-first Search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 104: Maximum Depth of Binary Tree]]></title>
    <url>%2F2018%2F10%2F06%2FLeetCode-104-Maximum-Depth-of-Binary-Tree%2F</url>
    <content type="text"><![CDATA[Given a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. Note: A leaf is a node with no children. Example:Given binary tree [3,9,20,null,null,15,7], 3 / \ 9 20 / \ 15 7 return its depth = 3. 12345type TreeNode struct &#123; Val int Left *TreeNode Right *TreeNode&#125; 123456789101112131415161718192021func maxDepth(root *TreeNode) int &#123; res := 0 if root == nil &#123; return res &#125; var queue []*TreeNode queue = append(queue, root) for len(queue) != 0 &#123; for _, v := range queue &#123; if v.Left != nil &#123; queue = append(queue, v.Left) &#125; if v.Right != nil &#123; queue = append(queue, v.Right) &#125; queue = queue[1:] &#125; res++ &#125; return res&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Tree</tag>
        <tag>Depth-first Search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 103: Binary Tree Zigzag Level Order Traversal]]></title>
    <url>%2F2018%2F10%2F06%2FLeetCode-103-Binary-Tree-Zigzag-Level-Order-Traversal%2F</url>
    <content type="text"><![CDATA[Given a binary tree, return the zigzag level order traversal of its nodes’ values. (ie, from left to right, then right to left for the next level and alternate between).For example:Given binary tree [3,9,20,null,null,15,7], 3 / \ 9 20 / \ 15 7 return its zigzag level order traversal as:[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[3],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[20,&nbsp;&nbsp;9],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[15,&nbsp;&nbsp;7]]12345type TreeNode struct &#123; Val int Left *TreeNode Right *TreeNode&#125; 12345678910111213141516171819202122232425262728293031323334353637383940func zigzagLevelOrder(root *TreeNode) [][]int &#123; var res [][]int if root == nil &#123; return res &#125; var s1, s2 []*TreeNode s1 = append(s1, root) for len(s1) != 0 || len(s2) != 0 &#123; var level1 []int for _, v1 := range s1 &#123; level1 = append(level1, v1.Val) if v1.Right != nil &#123; s2 = append(s2, v1.Right) &#125; if v1.Left != nil &#123; s2 = append(s2, v1.Left) &#125; s1 = s1[1:] &#125; if len(level1) != 0 &#123; res = append(res, level1) &#125; var level2 []int for _, v2 := range s2 &#123; level2 = append(level2, v2.Val) if v2.Left != nil &#123; s1 = append(s1, v2.Left) &#125; if v2.Right != nil &#123; s1 = append(s1, v2.Right) &#125; s2 = s2[1:] &#125; if len(level2) != 0 &#123; res = append(res, level2) &#125; &#125; return res&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Breadth-first Search</tag>
        <tag>Tree</tag>
        <tag>Stack</tag>
        <tag>Not solved</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 102: Binary Tree Level Order Traversal]]></title>
    <url>%2F2018%2F10%2F06%2FLeetCode-102-Binary-Tree-Level-Order-Traversal%2F</url>
    <content type="text"><![CDATA[Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level). For example:Given binary tree [3,9,20,null,null,15,7], 3 / \ 9 20 / \ 15 7 return its level order traversal as:[&nbsp;&nbsp;&nbsp;&nbsp;[3],&nbsp;&nbsp;&nbsp;&nbsp;[9,20],&nbsp;&nbsp;&nbsp;&nbsp;[15,7]]12345type TreeNode struct &#123; Val int Left *TreeNode Right *TreeNode&#125; 1234567891011121314151617181920212223func levelOrder(root *TreeNode) [][]int &#123; var res [][]int if root == nil &#123; return res &#125; var queue []*TreeNode queue = append(queue, root) for len(queue) != 0 &#123; var oneLevel []int for _, v := range queue &#123; oneLevel = append(oneLevel, v.Val) if v.Left != nil &#123; queue = append(queue, v.Left) &#125; if v.Right != nil &#123; queue = append(queue, v.Right) &#125; queue = queue[1:] &#125; res = append(res,oneLevel) &#125; return res&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Binary Tree</tag>
        <tag>Breadth-first Search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 98: Validate Binary Search Tree]]></title>
    <url>%2F2018%2F10%2F06%2FLeetCode-98-Validate-Binary-Search-Tree%2F</url>
    <content type="text"><![CDATA[Given a binary tree, determine if it is a valid binary search tree (BST). Assume a BST is defined as follows: The left subtree of a node contains only nodes with keys less than the node’s key. The right subtree of a node contains only nodes with keys greater than the node’s key. Both the left and right subtrees must also be binary search trees. Example 1:Input: 2 / \ 1 3 Output: true Example 2:Input: 5 / \ 1 4 / \ 3 6 Output: falseExplanation: The input is: [5,1,4,null,null,3,6]. The root node’s value is 5 but its right child’s value is 4. 12345type TreeNode struct &#123; Val int Left *TreeNode Right *TreeNode&#125; 12345678910func isBST(root *TreeNode, min, max int) bool &#123; if root == nil &#123; return true &#125; if root.Val &lt;= min || root.Val &gt;= max &#123; return false &#125; return isBST(root.Left,min,root.Val) &amp;&amp; isBST(root.Right,root.Val,max)&#125; 123func isValidBST(root *TreeNode) bool &#123; return isBST(root, -int(^uint(0) &gt;&gt; 1)-1, int(^uint(0) &gt;&gt; 1))&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Binary Tree</tag>
        <tag>Depth-first Search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 725: Split Linked List in Parts]]></title>
    <url>%2F2018%2F10%2F04%2FLeetCode-725-Split-Linked-List-in-Parts%2F</url>
    <content type="text"><![CDATA[Given a (singly) linked list with head node root, write a function to split the linked list into k consecutive linked list “parts”. The length of each part should be as equal as possible: no two parts should have a size differing by more than 1. This may lead to some parts being null.The parts should be in order of occurrence in the input list, and parts occurring earlier should always have a size greater than or equal parts occurring later. Return a List of ListNode’s representing the linked list parts that are formed. Examples 1-&gt;2-&gt;3-&gt;4, k = 5 // 5 equal parts [ [1], [2], [3], [4], null ] Example 1:Input:root = [1, 2, 3], k = 5Output: [\[1],[2],[3],[],[]]Explanation:The input and each element of the output are ListNodes, not arrays.For example, the input root has root.val = 1, root.next.val = 2, \root.next.next.val = 3, and root.next.next.next = null.The first element output[0] has output[0].val = 1, output[0].next = null.The last element output[4] is null, but it’s string representation as a ListNode is []. Example 2:Input:root = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], k = 3Output: [\[1, 2, 3, 4], [5, 6, 7], [8, 9, 10]]Explanation:The input has been split into consecutive parts with size difference at most 1, and earlier parts are a larger size than the later parts. Note: The length of root will be in the range [0, 1000]. Each value of a node in the input will be an integer in the range [0, 999]. k will be an integer in the range [1, 50]. 1234type ListNode struct &#123; Val int Next *ListNode&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546func splitListToParts(root *ListNode, k int) []*ListNode &#123; var res []*ListNode var n int tmp := root for tmp != nil &#123; tmp = tmp.Next n++ &#125; if n &lt; k &#123; for t := 0; t &lt; n; t++ &#123; shortTmp := root root = root.Next shortTmp.Next = nil res = append(res, shortTmp) &#125; for u := n; u &lt; k; u++ &#123; shortTmp := new(ListNode) res = append(res, shortTmp.Next) &#125; return res &#125; usual, more := n / k, n % k for i := 0; i &lt; more; i++ &#123; listTmp := root for t := 0; t &lt; usual; t++ &#123; root = root.Next &#125; now := root.Next root.Next = nil res = append(res, listTmp) root = now &#125; for j := 0; j &lt; k - more; j++ &#123; longTmp := root for n := 0; n &lt; usual - 1; n++ &#123; root = root.Next &#125; now := root.Next root.Next = nil res = append(res, longTmp) root = now &#125; return res&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 445: Add Two Numbers II]]></title>
    <url>%2F2018%2F10%2F04%2FLeetCode-445-Add-Two-Numbers-II%2F</url>
    <content type="text"><![CDATA[You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.You may assume the two numbers do not contain any leading zero, except the number 0 itself. Follow up:What if you cannot modify the input lists? In other words, reversing the lists is not allowed. Example:Input: (7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 8 -&gt; 0 -&gt; 7 1234type ListNode struct &#123; Val int Next *ListNode&#125; 12345678910111213141516171819202122232425262728293031func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode &#123; var s1, s2 []int for l1 != nil &#123; s1 = append(s1, l1.Val) l1 = l1.Next &#125; for l2 != nil &#123; s2 = append(s2, l2.Val) l2 = l2.Next &#125; var sum int res := new(ListNode) for len(s1) != 0 || len(s2) != 0 &#123; if len(s1) != 0 &#123; sum += s1[len(s1)-1] s1 = s1[:len(s1)-1] &#125; if len(s2) != 0 &#123; sum += s2[len(s2)-1] s2 = s2[:len(s2)-1] &#125; res.Val = sum % 10 head := &amp;ListNode&#123;sum / 10, res&#125; res = head sum = sum / 10 &#125; if res.Val == 0 &#123; return res.Next &#125; return res&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 206: Reverse Linked List]]></title>
    <url>%2F2018%2F10%2F04%2FLeetCode-206-Reverse-Linked-List%2F</url>
    <content type="text"><![CDATA[Reverse a singly linked list. Example:Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULLOutput: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULLFollow up:A linked list can be reversed either iteratively or recursively. Could you implement both? 1234type ListNode struct &#123; Val int Next *ListNode&#125; 12345678910func reverseList(head *ListNode) *ListNode &#123; var res *ListNode for head != nil &#123; temp := head.Next head.Next = res res = head head = temp &#125; return res&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 19: Remove Nth Node From End of List]]></title>
    <url>%2F2018%2F10%2F04%2FLeetCode-19-Remove-Nth-Node-From-End-of-List%2F</url>
    <content type="text"><![CDATA[Given a linked list, remove the n-th node from the end of list and return its head. Example:Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5. Note: Given n will always be valid. 123456789101112131415161718192021public ListNode removeNthFromEnd(ListNode head, int n) &#123; int len = 0; ListNode cur = head, point = head; while (cur.next != null) &#123; cur = cur.next; len++; if (len &gt; n) point = point.next; &#125; if (len &lt; n - 1) &#123; ListNode res = null; return res; &#125;else if (len == n - 1) &#123; head = head.next; &#125;else &#123; point.next = point.next.next; &#125; return head;&#125; 1234type ListNode struct &#123; Val int Next *ListNode&#125; 123456789101112131415161718192021func removeNthFromEnd(head *ListNode, n int) *ListNode &#123; ahead, res := head, head for i := 0; i &lt; n; i++ &#123; ahead = ahead.Next &#125; if ahead == nil &#123; return res.Next &#125; for ahead.Next != nil &#123; ahead = ahead.Next head = head.Next &#125; if head.Next != nil &#123; head.Next = head.Next.Next &#125;else &#123; head.Next = nil &#125; return res&#125;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Amazon</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
        <tag>Two Pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 817: Linked List Components]]></title>
    <url>%2F2018%2F10%2F03%2FLeetCode-817-Linked-List-Components%2F</url>
    <content type="text"><![CDATA[We are given head, the head node of a linked list containing unique integer values. We are also given the list G, a subset of the values in the linked list. Return the number of connected components in G, where two values are connected if they appear consecutively in the linked list.Example 1:Input:head: 0-&gt;1-&gt;2-&gt;3G = [0, 1, 3]Output: 2Explanation:0 and 1 are connected, so [0, 1] and [3] are the two connected components. Example 2:Input:head: 0-&gt;1-&gt;2-&gt;3-&gt;4G = [0, 3, 1, 4]Output: 2Explanation:0 and 1 are connected, 3 and 4 are connected, so [0, 1] and [3, 4] are the two connected components. Note: If N is the length of the linked list given by head, 1 &lt;= N &lt;= 10000. The value of each node in the linked list will be in the range [0, N - 1]. 1 &lt;= G.length &lt;= 10000. G is a subset of all values in the linked list. 1234type ListNode struct &#123; Val int Next *ListNode&#125; 12345678910111213141516171819func numComponents(head *ListNode, G []int) int &#123; m := make(map[int]bool) for _, v := range G &#123; m[v] = true &#125; var res int for head.Next != nil &#123; _, exist1 := m[head.Val] _, exist2 := m[head.Next.Val] if exist1 &amp;&amp; (head.Next == nil || !exist2) &#123; res++ &#125; head = head.Next &#125; if _, exist := m[head.Val]; exist &#123; res++ &#125; return res&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 369: Plus One Linked List]]></title>
    <url>%2F2018%2F10%2F03%2FLeetCode-369-Plus-One-Linked-List%2F</url>
    <content type="text"><![CDATA[Given a non-negative integer represented as non-empty a singly linked list of digits, plus one to the integer. You may assume the integer do not contain any leading zero, except the number 0 itself.The digits are stored such that the most significant digit is at the head of the list. Example :Input: [1,2,3]Output: [1,2,4] 1234type ListNode struct &#123; Val int Next *ListNode&#125; 1234567891011121314func everyOne(head *ListNode) (*ListNode, int) &#123; if head.Next == nil &#123; carry := (head.Val + 1) / 10 head.Val = (head.Val + 1) % 10 return head, carry &#125; res, carry := everyOne(head.Next) if carry == 1 &#123; carry = (head.Val + 1) / 10 head.Val = (head.Val + 1) % 10 &#125; head.Next = res return head, carry&#125; 12345678func plusOne(head *ListNode) *ListNode &#123; res, carry := everyOne(head) if carry == 1 &#123; newHead := &amp;ListNode&#123;1, res&#125; return newHead &#125; return res&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 203: Remove Linked List Elements]]></title>
    <url>%2F2018%2F10%2F03%2FLeetCode-203-Remove-Linked-List-Elements%2F</url>
    <content type="text"><![CDATA[Remove all elements from a linked list of integers that have value val.Example:Input: 1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val = 6Output: 1-&gt;2-&gt;3-&gt;4-&gt;5 1234type ListNode struct &#123; Val int Next *ListNode&#125; 12345678910111213func removeElements(head *ListNode, val int) *ListNode &#123; newHead := new(ListNode) newHead.Next = head tail := newHead for tail != nil &#123; if tail.Next.Val == val &#123; tail.Next = tail.Next.Next &#125;else &#123; tail = tail.Next &#125; &#125; return newHead.Next&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 21: Merge Two Sorted Lists]]></title>
    <url>%2F2018%2F10%2F03%2FLeetCode-21-Merge-Two-Sorted-Lists%2F</url>
    <content type="text"><![CDATA[Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists. Example:Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;41234567891011public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if (l1 == null) return l2; if (l2 == null) return l1; if (l1.val &lt; l2.val) &#123; l1.next = mergeTwoLists(l1.next, l2); return l1; &#125; else &#123; l2.next = mergeTwoLists(l1, l2.next); return l2; &#125;&#125; 1234type ListNode struct &#123; Val int Next *ListNode&#125; 123456789101112131415161718192021func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode &#123; head := new(ListNode) tail := head for l1 != nil &amp;&amp; l2 != nil &#123; if l1.Val &lt;= l2.Val &#123; tail.Next = l1 tail = l1 l1 = l1.Next &#125;else &#123; tail.Next = l2 tail = l2 l2 = l2.Next &#125; &#125; if l1 == nil &#123; tail.Next = l2 &#125;else &#123; tail.Next = l1 &#125; return head.Next&#125;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Amazon</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 750: Number Of Corner Rectangles]]></title>
    <url>%2F2018%2F10%2F03%2FLeetCode-750-Number-Of-Corner-Rectangles%2F</url>
    <content type="text"><![CDATA[Given a grid where each entry is only 0 or 1, find the number of corner rectangles. A corner rectangle is 4 distinct 1s on the grid that form an axis-aligned rectangle. Note that only the corners need to have the value 1. Also, all four 1s used must be distinct.Example 1: Input: grid = [&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[1,&nbsp;&nbsp;0,&nbsp;&nbsp;0,&nbsp;&nbsp;1,&nbsp;&nbsp;0],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[0,&nbsp;&nbsp;0,&nbsp;&nbsp;1,&nbsp;&nbsp;0,&nbsp;&nbsp;1],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[0,&nbsp;&nbsp;0,&nbsp;&nbsp;0,&nbsp;&nbsp;1,&nbsp;&nbsp;0],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[1,&nbsp;&nbsp;0,&nbsp;&nbsp;1,&nbsp;&nbsp;0,&nbsp;&nbsp;1] ]Output: 1Explanation: There is only one corner rectangle, with corners grid[1][2], grid[1][4], grid[3][2], grid[3][4]. Example 2: Input: grid = [&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[1,&nbsp;&nbsp;1,&nbsp;&nbsp;1],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[1,&nbsp;&nbsp;1,&nbsp;&nbsp;1],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[1,&nbsp;&nbsp;1,&nbsp;&nbsp;1]]Output: 9Explanation: There are four 2x2 rectangles, four 2x3 and 3x2 rectangles, and one 3x3 rectangle. Example 3: Input: grid = [&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[1,&nbsp;&nbsp;1,&nbsp;&nbsp;1,&nbsp;&nbsp;1]]Output: 0Explanation: Rectangles must have four distinct corners. Note: The number of rows and columns of grid will each be in the range [1, 200]. Each grid[i][j] will be either 0 or 1. The number of 1s in the grid will be at most 6000. 12345678910111213141516func countCornerRectangles(grid [][]int) int &#123; var res int for i := 0; i &lt; len(grid); i++ &#123; for j := i + 1; j &lt; len(grid); j++ &#123; count := 0 for k := 0; k &lt; len(grid[0]); k++ &#123; if grid[i][k] == 1 &amp;&amp; grid[j][k] == 1 &#123; count++ &#125; &#125; res += count * (count - 1) / 2 &#125; &#125; return res &#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode 418: Sentence Screen Fitting]]></title>
    <url>%2F2018%2F10%2F02%2FLeetcode-418-Sentence-Screen-Fitting%2F</url>
    <content type="text"><![CDATA[Given a rows x cols screen and a sentence represented by a list of non-empty words, find how many times the given sentence can be fitted on the screen. Note: A word cannot be split into two lines. The order of words in the sentence must remain unchanged. Two consecutive words in a line must be separated by a single space. Total words in the sentence won’t exceed 100. Length of each word is greater than 0 and won’t exceed 10. 1 ≤ rows, cols ≤ 20,000. Example 1:Input:rows = 2, cols = 8, sentence = [“hello”, “world”]Output: 1Explanation:hello—world— The character ‘-‘ signifies an empty space on the screen. Example 2:Input:rows = 3, cols = 6, sentence = [“a”, “bcd”, “e”]Output: 2Explanation:a-bcd-e-a—bcd-e- The character ‘-‘ signifies an empty space on the screen. Example 3:Input:rows = 4, cols = 5, sentence = [“I”, “had”, “apple”, “pie”]Output: 1Explanation:I-hadapplepie-Ihad– The character ‘-‘ signifies an empty space on the screen. 1234567891011121314151617181920212223242526func wordsTyping(sentence []string, rows int, cols int) int &#123; left, res, count := cols, 0, 0 for i := 0; i &lt; rows; i++ &#123; for &#123; if count == len(sentence) &#123; count = 0 res += 1 &#125; if left &lt; len(sentence[count]) &#123; left = cols break &#125;else if left == len(sentence[count]) &#123; count++ left = cols break &#125; left -= len(sentence[count]) + 1 count++ &#125; &#125; if count == len(sentence) &#123; count = 0 res += 1 &#125; return res&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode 416: Partition Equal Subset Sum]]></title>
    <url>%2F2018%2F10%2F02%2FLeetcode-416-Partition-Equal-Subset-Sum%2F</url>
    <content type="text"><![CDATA[Given a non-empty array containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal. Note: Each of the array element will not exceed 100. The array size will not exceed 200. Example 1:Input: [1, 5, 11, 5]Output: trueExplanation: The array can be partitioned as [1, 5, 5] and [11]. Example 2:Input: [1, 2, 3, 5]Output: falseExplanation: The array cannot be partitioned into equal sum subsets. 1234567891011121314151617181920func canPartition(nums []int) bool &#123; var sum, target int for _, v := range nums &#123; sum += v &#125; if sum % 2 == 1 &#123; return false &#125;else &#123; target = sum &gt;&gt; 1 &#125; dp := make([]bool, target + 1) dp[0] = true for _, n := range nums &#123; for i := target; i &gt;= n; i-- &#123; dp[i] = dp[i] || dp[i - n] &#125; &#125; return dp[target] &#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 375: Guess Number Higher or Lower II]]></title>
    <url>%2F2018%2F09%2F28%2FLeetCode-375-Guess-Number-Higher-or-Lower-II%2F</url>
    <content type="text"><![CDATA[We are playing the Guess Game. The game is as follows: I pick a number from 1 to n. You have to guess which number I picked. Every time you guess wrong, I’ll tell you whether the number I picked is higher or lower.However, when you guess a particular number x, and you guess wrong, you pay \$x. You win the game when you guess the number I picked. Example:n = 10, I pick 8. First round: You guess 5, I tell you that it’s higher. You pay \$5.Second round: You guess 7, I tell you that it’s higher. You pay \$7.Third round: You guess 9, I tell you that it’s lower. You pay \$9. Game over. 8 is the number I picked. You end up paying \$5 + \$7 + \$9 = \$21.Given a particular n ≥ 1, find out how much money you need to have to guarantee a win. 1234567func getMoneyAmount(n int) int &#123; m := make([][]int, n + 1) for t := range m &#123; m[t] = make([]int, n + 1) &#125; return guessMoney(1, n, m)&#125; 123456789101112131415161718192021222324func guessMoney(start, end int, m [][]int) int &#123; if start &gt;= end &#123; return 0 &#125; if m[start][end] &gt; 0 &#123; return m[start][end] &#125; res := 0x7FFFFFFF for i := start; i &lt; end; i++ &#123; a := guessMoney(start, i - 1, m) b := guessMoney(i + 1, end, m) if a &gt; b &#123; if i + a &lt; res &#123; res = i + a &#125; &#125;else &#123; if i + b &lt; res &#123; res = i + b &#125; &#125; &#125; m[start][end] = res return res&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
        <tag>Minimax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 304: Range Sum Query 2D - Immutable]]></title>
    <url>%2F2018%2F09%2F28%2FLeetCode-304-Range-Sum-Query-2D-Immutable%2F</url>
    <content type="text"><![CDATA[Given a 2D matrix matrix, find the sum of the elements inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2).The above rectangle (with the red border) is defined by (row1, col1) = (2, 1) and (row2, col2) = (4, 3), which contains sum = 8.Example: Given matrix = [&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[3,&nbsp;&nbsp;0,&nbsp;&nbsp;1,&nbsp;&nbsp;4,&nbsp;&nbsp;2],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[5,&nbsp;&nbsp;6,&nbsp;&nbsp;3,&nbsp;&nbsp;2,&nbsp;&nbsp;1],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[1,&nbsp;&nbsp;2,&nbsp;&nbsp;0,&nbsp;&nbsp;1,&nbsp;&nbsp;5],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[4,&nbsp;&nbsp;1,&nbsp;&nbsp;0,&nbsp;&nbsp;1,&nbsp;&nbsp;7],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[1,&nbsp;&nbsp;0,&nbsp;&nbsp;3,&nbsp;&nbsp;0,&nbsp;&nbsp;5]] sumRegion(2, 1, 4, 3) -&gt; 8sumRegion(1, 1, 2, 2) -&gt; 11sumRegion(1, 2, 2, 4) -&gt; 12 Note: You may assume that the matrix does not change. There are many calls to sumRegion function. You may assume that row1 ≤ row2 and col1 ≤ col2. 123type NumMatrix struct &#123; dp [][]int&#125; 12345678910111213141516171819202122func Constructor(matrix [][]int) NumMatrix &#123; var m, n int if len(matrix) == 0 || len(matrix[0]) == 0 &#123; m, n = 0, 0 &#125;else &#123; m, n = len(matrix), len(matrix[0]) &#125; dp := make([][]int, m + 1) for v := range dp &#123; dp[v] = make([]int, n + 1) &#125; for i := 1; i &lt;= m; i++ &#123; for j := 1; j &lt;=n; j++ &#123; dp[i][j] = matrix[i-1][j-1] + dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1] &#125; &#125; return NumMatrix&#123;dp: dp&#125;&#125;func (this *NumMatrix) SumRegion(row1 int, col1 int, row2 int, col2 int) int &#123; return this.dp[row2+1][col2+1] - this.dp[row2+1][col1] - this.dp[row1][col2+1] + this.dp[row1][col1]&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 221: Maximal Square]]></title>
    <url>%2F2018%2F09%2F28%2FLeetCode-221-Maximal-Square%2F</url>
    <content type="text"><![CDATA[Given a 2D binary matrix filled with 0’s and 1’s, find the largest square containing only 1’s and return its area. Example:Input: 1&nbsp;&nbsp;0&nbsp;&nbsp;1&nbsp;&nbsp;0&nbsp;&nbsp;01&nbsp;&nbsp;0&nbsp;&nbsp;1&nbsp;&nbsp;1&nbsp;&nbsp;11&nbsp;&nbsp;1&nbsp;&nbsp;1&nbsp;&nbsp;1&nbsp;&nbsp;11&nbsp;&nbsp;0&nbsp;&nbsp;0&nbsp;&nbsp;1&nbsp;&nbsp;0 Output: 4Solution 1:1234567891011121314151617181920212223242526272829303132333435func maximalSquare(matrix [][]byte) int &#123; if len(matrix) == 0 || len(matrix[0]) == 0 &#123; return 0 &#125; res := 0 dp := make([][]int, len(matrix)) for t := range dp &#123; dp[t] = make([]int, len(matrix[0])) &#125; for i := range matrix &#123; for j := range matrix[i] &#123; if i == 0 || j == 0 &#123; dp[i][j] = int(matrix[i][j]) - '0' &#125;else if int(matrix[i][j]) == '1' &#123; if dp[i-1][j] &lt; dp[i][j-1] &#123; if dp[i-1][j] &lt; dp[i-1][j-1] &#123; dp [i][j] = dp[i-1][j] + 1 &#125;else &#123; dp[i][j] = dp[i-1][j-1] + 1 &#125; &#125;else &#123; if dp[i][j-1] &lt; dp[i-1][j-1] &#123; dp [i][j] = dp[i][j-1] + 1 &#125;else &#123; dp[i][j] = dp[i-1][j-1] + 1 &#125; &#125; &#125; if res &lt; dp[i][j] &#123; res = dp[i][j] &#125; &#125; &#125; return res * res &#125; Soluton 2:1234567891011121314151617181920212223242526272829303132333435func maximalSquare(matrix [][]byte) int &#123; if len(matrix) == 0 || len(matrix[0]) == 0 &#123; return 0 &#125; dp := [2][]int&#123;make([]int, len(matrix[0])+1), make([]int, len(matrix[0])+1)&#125; res, curr := 0, 0 for i := range matrix &#123; prev := curr curr = 1 - curr for j := range matrix[i] &#123; if matrix[i][j] == '0' &#123; dp[curr][j+1] = 0 continue &#125; if dp[curr][j] &lt; dp[prev][j] &#123; if dp[curr][j] &lt; dp[prev][j+1] &#123; dp[curr][j+1] = dp[curr][j] + 1 &#125;else &#123; dp[curr][j+1] = dp[prev][j+1] + 1 &#125; &#125;else &#123; if dp[prev][j] &lt; dp[prev][j+1] &#123; dp[curr][j+1] = dp[prev][j] + 1 &#125;else &#123; dp[curr][j+1] = dp[prev][j+1] + 1 &#125; &#125; if res &lt; dp[curr][j+1] &#123; res = dp[curr][j+1] &#125; &#125; &#125; return res * res&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 198: House Robber]]></title>
    <url>%2F2018%2F09%2F28%2FLeetCode-198-House-Robber%2F</url>
    <content type="text"><![CDATA[You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. Example 1:Input: [1,2,3,1]Output: 4Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3). Total amount you can rob = 1 + 3 = 4. Example 2:Input: [2,7,9,3,1]Output: 12Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).Total amount you can rob = 2 + 9 + 1 = 12. 123456789101112131415161718192021222324func rob(nums []int) int &#123; var even, odd, res int for i, v := range nums &#123; if i % 2 == 0 &#123; if even + v &gt; odd &#123; even = even + v &#125;else &#123; even = odd &#125; &#125;else &#123; if odd + v &gt; even &#123; odd = odd + v &#125;else &#123; odd = even &#125; &#125; &#125; if even &gt; odd &#123; res = even &#125;else &#123; res = odd &#125; return res&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 188: Best Time to Buy and Sell Stock IV]]></title>
    <url>%2F2018%2F09%2F28%2FLeetCode-188-Best-Time-to-Buy-and-Sell-Stock-IV%2F</url>
    <content type="text"><![CDATA[Say you have an array for which the $i^{th}$ element is the price of a given stock on day $i$. Design an algorithm to find the maximum profit. You may complete at most k transactions.Note:You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). Example 1:Input: [2,4,1], k = 2Output: 2Explanation: Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2. Example 2:Input: [3,2,6,5,0,3], k = 2Output: 7Explanation: Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4. Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3. 12345678910111213141516171819202122func maxProfit(k int, prices []int) int &#123; if k &gt; len(prices) &#123; k = len(prices) &#125; var bp, sp []int for i := 0; i &lt; k; i++ &#123; bp = append(bp, -0x80000000) sp = append(sp, 0) &#125; sp = append(sp, 0) for _, v := range prices &#123; for j := 0; j &lt; k; j++ &#123; if bp[i] &lt; sp[i] - v &#123; bp[i] = sp[i] - v &#125; if sp[i+1] &lt; v + bp[i] &#123; sp[i+1] = v + bp[i] &#125; &#125; &#125; return sp[k]&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 139: Word Break]]></title>
    <url>%2F2018%2F09%2F28%2FLeetCode-139-Word-Break%2F</url>
    <content type="text"><![CDATA[Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words.Note: The same word in the dictionary may be reused multiple times in the segmentation. You may assume the dictionary does not contain duplicate words. Example 1:Input: s = “leetcode”, wordDict = [“leet”, “code”]Output: trueExplanation: Return true because “leetcode” can be segmented as “leet code”. Example 2:Input: s = “applepenapple”, wordDict = [“apple”, “pen”]Output: trueExplanation: Return true because “applepenapple” can be segmented as “apple pen apple”. Note that you are allowed to reuse a dictionary word. Example 3:Input: s = “catsandog”, wordDict = [“cats”, “dog”, “sand”, “and”, “cat”]Output: false 1234567891011121314151617181920212223242526func wordBreak(s string, wordDict []string) bool &#123; if len(wordDict) == 0 &#123; return false &#125; dict := make(map[string]bool) length := []int for _, v := range wordDict &#123; if _, exist := dict[v]; !exist &#123; dict[v] = true length = append(length,len(v)) &#125; &#125; dp := make([]bool, len(s)+1) dp[0] = true for i := 0; i &lt; len(s); i++ &#123; if !dp[i] &#123; continue &#125; for _, size := range length &#123; dp[i+size] = dp[i+size] || dict[s[i:i+size]] &#125; &#125; return dp[len(s)]&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 10: Regular Expression Matching]]></title>
    <url>%2F2018%2F09%2F28%2FLeetCode-10-Regular-Expression-Matching%2F</url>
    <content type="text"><![CDATA[Given an input string (s) and a pattern (p), implement regular expression matching with support for ‘.’ and ‘*’. ‘.’ Matches any single character.‘*’ Matches zero or more of the preceding element.The matching should cover the entire input string (not partial).Note: s could be empty and contains only lowercase letters a-z. p could be empty and contains only lowercase letters a-z, and characters like . or *. Example 1:Input:s = “aa”p = “a”Output: falseExplanation: “a” does not match the entire string “aa”. Example 2:Input:s = “aa”p = “a“Output: trueExplanation: ‘‘ means zero or more of the precedeng element, ‘a’. Therefore, by repeating ‘a’ once, it becomes “aa”. Example 3:Input:s = “ab”p = “.“Output: trueExplanation: “.“ means “zero or more (*) of any character (.)”. Example 4:Input:s = “aab”p = “cab”Output: trueExplanation: c can be repeated 0 times, a can be repeated 1 time. Therefore it matches “aab”. Example 5:Input:s = “mississippi”p = “misisp*.”Output: false 12345678910111213141516171819func isMatch(s string, p string) bool &#123; dp := make([][]bool, len(s)+1) for i := range dp &#123; dp[i] = make([]bool, len(p)+1) &#125; dp[len(s)][len(p)] = true for i := len(s); i &gt;= 0; i-- &#123; for j := len(p) - 1; j &gt;= 0; j-- &#123; firstMatch := i &lt; len(s) &amp;&amp; (p[j] == s[i] || p[j] == '.') if j+1 &lt; len(p) &amp;&amp; p[j + 1] == '*' &#123; dp[i][j] = dp[i][j + 2] || firstMatch &amp;&amp; dp[i + 1][j] &#125;else &#123; dp[i][j] = firstMatch &amp;&amp; dp[i + 1][j + 1] &#125; &#125; &#125; return dp[0][0]&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 8: String to Integer (atoi)]]></title>
    <url>%2F2018%2F09%2F28%2FLeetCode-8-String-to-Integer-atoi%2F</url>
    <content type="text"><![CDATA[Implement atoi which converts a string to an integer. The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value. The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed. If no valid conversion could be performed, a zero value is returned. Note: Only the space character ‘ ‘ is considered as whitespace character. Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: $[−2^{31}, 2^{31 − 1}]$. If the numerical value is out of the range of representable values, INT_MAX ($2^{31 − 1}$) or INT_MIN ($−2^{31}$) is returned. Example 1:Input: “42”Output: 42 Example 2:Input: “ -42”Output: -42Explanation: The first non-whitespace character is ‘-‘, which is the minus sign. Then take as many numerical digits as possible, which gets 42. Example 3:Input: “4193 with words”Output: 4193Explanation: Conversion stops at digit ‘3’ as the next character is not a numerical digit. Example 4:Input: “words and 987”Output: 0Explanation: The first non-whitespace character is ‘w’, which is not a numerical digit or a +/- sign. Therefore no valid conversion could be performed. Example 5:Input: “-91283472332”Output: -2147483648Explanation: The number “-91283472332” is out of the range of a 32-bit signed integer. Thefore INT_MIN ($−2^{31}$) is returned. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748func myAtoi(str string) int &#123; s := strings.TrimSpace(str) if len(s) == 0 &#123; return 0 &#125; symbol := ‘+’ if s[0] == ‘-’ &#123; symbol = ‘-’ s = s[1:] &#125;else s[0] == ‘+’ &#123; s = s[1:] &#125; if len(s) == 0 &#123; return 0 &#125; if s[0] &lt; ‘0’ || s[0] &gt; ‘9’ &#123; return 0 &#125; for i := range s &#123; if s[i] &lt; ‘0’ || s[i] &gt; ‘9’ &#123; s = s[:i] break &#125; &#125; res := 0 for _, ch := range []byte(s) &#123; ch -= ‘0’ if ch &gt; 9 &#123; return 0 &#125; res = res*10 + int(ch) if res &gt; 0x7FFFFFFF &#123; if symbol == ‘-’ &#123; return -0x80000000 &#125; return 0x7FFFFFFF &#125; &#125; if symbol == ‘-’ &#123; res = -res &#125; return res&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 7: Reverse Integer]]></title>
    <url>%2F2018%2F09%2F28%2FLeetCode-7-Reverse-Integer%2F</url>
    <content type="text"><![CDATA[Given a 32-bit signed integer, reverse digits of an integer. Example 1:Input: 123Output: 321Example 2:Input: -123Output: -321 Example 3:Input: 120Output: 21 Note:Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: $[−2^{31}, 2^{31 − 1}]$. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows. 1234567891011121314func reverse(x int) int &#123; res := 0 for &#123; res = res * 10 + x % 10 if x / 10 == 0 &#123; break &#125; x = x / 10 &#125; if x &lt; -0x80000000 || x &gt; 0x7FFFFFFF &#123; return 0 &#125; return res&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 5: Longest Palindromic Substring]]></title>
    <url>%2F2018%2F09%2F28%2FLeetCode-5-Longest-Palindromic-Substring%2F</url>
    <content type="text"><![CDATA[Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. Example 1:Input: “babad”Output: “bab”Note: “aba” is also a valid answer.Example 2:Input: “cbbd”Output: “bb” 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public String longestPalindrome(String s) &#123; if (s.length() == 0 || s.length() == 1) return s; int index = 0, max = 1, i = 0; while (i &lt; s.length()) &#123; if (s.length() - i &lt;= max / 2) break; int begin = i, end = i; while (end &lt; s.length() - 1 &amp;&amp; s.charAt(end + 1) == s.charAt(end)) end++; i = end + 1; while (end &lt; s.length() - 1 &amp;&amp; begin &gt; 0 &amp;&amp; s.charAt(end + 1) == s.charAt(begin - 1)) &#123; end++; begin--; &#125; int length = end + 1 - begin; if (length &gt; max) &#123; index = begin; max = length; &#125; &#125; return s.substring(index, index + max);&#125;``` ``` gofunc longestPalindrome(s string) string &#123; if len(s) &lt; 2 &#123; return s &#125; index, max := 0, 0 for i := 0; i &lt; len(s) &#123; if len(s) - i &gt; max / 2 &#123; break &#125; begin, end := i, i for end &lt; len(s) - 1 &amp;&amp; s[i] == s[i+1] &#123; end++ &#125; i = end + 1 for end &lt; len(s) - 1 &amp;&amp; begin &gt; 0 &amp;&amp; s[end+1] == s[begin-1] &#123; end++ begin-- &#125; length := end - begin + 1 if max &lt; length &#123; max = length index = begin &#125; &#125; return s[index: index + max]&#125;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Amazon</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 3: Longest Substring Without Repeating Characters]]></title>
    <url>%2F2018%2F09%2F28%2FLeetCode-3-Longest-Substring-Without-Repeating-Characters%2F</url>
    <content type="text"><![CDATA[Given a string, find the length of the longest substring without repeating characters. Example 1:Input: “abcabcbb”Output: 3Explanation: The answer is “abc”, with the length of 3.Example 2:Input: “bbbbb”Output: 1Explanation: The answer is “b”, with the length of 1. Example 3:Input: “pwwkew”Output: 3Explanation: The answer is “wke”, with the length of 3. Note that the answer must be a substring, “pwke” is a subsequence and not a substring. 123456789101112131415161718192021func lengthOfLongestSubstring(s string) int &#123; m := make(map[uint8]int) res := 0 start, end := 0, 0 for end &lt; len(s) &#123; if p, exist := m[s[end]]; exist &#123; start = p + 1 end = start for k, _ := range m &#123; delete(m, k) &#125; &#125;else &#123; m[s[end]] = end if end - start + 1 &gt; res &#123; res = end - start + 1 &#125; end++ &#125; &#125; return res&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Hash Table</tag>
        <tag>String</tag>
        <tag>Two Pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 2: Add Two Numbers]]></title>
    <url>%2F2018%2F09%2F28%2FLeetCode-2-Add-Two-Numbers%2F</url>
    <content type="text"><![CDATA[You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself.Example:Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8Explanation: 342 + 465 = 807. 1234type ListNode struct &#123; Val interface&#123;&#125; Next *ListNode&#125; 123456789101112131415161718192021func addTwoNumbers(a, b *ListNode) *ListNode &#123; head := new(ListNode) node := head carray := 0 for a != nil || b != nil || carray != 0 &#123; sum := carry if a != nil &#123; sum += a.Val a = a.Next &#125; if b != nil &#123; sum += b.Val b = b.Next &#125; carry = sum / 10 node.Next = new(ListNode) node.Next.Val = sum % 10 node = node.Next &#125; return head.Next&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 1: Two Sum]]></title>
    <url>%2F2018%2F09%2F27%2FLeetCode-1-Two-Sum%2F</url>
    <content type="text"><![CDATA[Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice.Example:Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. 1234567891011121314151617func twoSum(nums []int, target int) []int &#123; var res []int m := make(map[int]int) for i := 0; i &lt; len(nums); i++ &#123; if v,exist := m[target-nums[i]];exist &#123; if v &lt; i &#123; res = append(res,v,i) &#125;else &#123; res = append(res,i,v) &#125; break &#125;else &#123; m[nums[i]] = i &#125; &#125; return res&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Hash Table</tag>
      </tags>
  </entry>
</search>
