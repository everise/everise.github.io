<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LeetCode 346: Moving Average from Data Stream]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-346-Moving-Average-from-Data-Stream%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 486: Predict the Winner]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-486-Predict-the-Winner%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 734: Sentence Similarity]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-734-Sentence-Similarity%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 307: Range Sum Query - Mutable]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-307-Range-Sum-Query-Mutable%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 447: Number of Boomerangs]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-447-Number-of-Boomerangs%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 776: Split BST]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-776-Split-BST%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 424: Longest Repeating Character Replacement]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-424-Longest-Repeating-Character-Replacement%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 457: Circular Array Loop]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-457-Circular-Array-Loop%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 766: Toeplitz Matrix]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-766-Toeplitz-Matrix%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 849: Maximize Distance to Closest Person]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-849-Maximize-Distance-to-Closest-Person%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 731: My Calendar II]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-731-My-Calendar-II%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 846: Hand of Straights]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-846-Hand-of-Straights%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 418: Sentence Screen Fitting]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-418-Sentence-Screen-Fitting-0%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 205: Isomorphic Strings]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-205-Isomorphic-Strings%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 833: Find And Replace in String]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-833-Find-And-Replace-in-String%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 562: Longest Line of Consecutive One in Matrix]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-562-Longest-Line-of-Consecutive-One-in-Matrix%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 299: Bulls and Cows]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-299-Bulls-and-Cows%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 686: Repeated String Match]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-686-Repeated-String-Match%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 904: Fruit Into Baskets]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-904-Fruit-Into-Baskets%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 844: Backspace String Compare]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-844-Backspace-String-Compare%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 482: License Key Formatting]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-482-License-Key-Formatting%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 681: Next Closest Time]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-681-Next-Closest-Time%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 91: Decode Ways]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-91-Decode-Ways%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 80: Remove Duplicates from Sorted Array II]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-80-Remove-Duplicates-from-Sorted-Array-II%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 76: Minimum Window Substring]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-76-Minimum-Window-Substring%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 75: Sort Colors]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-75-Sort-Colors%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 72: Edit Distance]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-72-Edit-Distance%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 70: Climbing Stairs]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-70-Climbing-Stairs%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 69: Sqrt(x)]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-69-Sqrt-x%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 66: Plus One]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-66-Plus-One%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 62: Unique Paths]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-62-Unique-Paths%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 60: Permutation Sequence]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-60-Permutation-Sequence%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 56: Merge Intervals]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-56-Merge-Intervals%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 54: Spiral Matrix]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-54-Spiral-Matrix%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 50: Pow(x, n)]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-50-Pow-x-n%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 49: Group Anagrams]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-49-Group-Anagrams%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 48: Rotate Image]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-48-Rotate-Image%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 43: Multiply Strings]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-43-Multiply-Strings%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 38: Count and Say]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-38-Count-and-Say%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 36: Valid Sudoku]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-36-Valid-Sudoku%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 35: Search Insert Position]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-35-Search-Insert-Position%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 34: Find First and Last Position of Element in Sorted Array]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-34-Find-First-and-Last-Position-of-Element-in-Sorted-Array%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 33: Search in Rotated Sorted Array]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-33-Search-in-Rotated-Sorted-Array%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 31: Next Permutation]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-31-Next-Permutation%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 26: Remove Duplicates from Sorted Array]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-26-Remove-Duplicates-from-Sorted-Array%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 20: Valid Parentheses]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-20-Valid-Parentheses%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 15: 3Sum]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-15-3Sum%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 14: Longest Common Prefix]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-14-Longest-Common-Prefix%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 13: Roman to Integer]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-13-Roman-to-Integer%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 11: Container With Most Water]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-11-Container-With-Most-Water%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 6: ZigZag Conversion]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-6-ZigZag-Conversion%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 78: Subsets]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-78-Subsets%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 46: Permutations]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-46-Permutations%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 22: Generate Parentheses]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-22-Generate-Parentheses%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 17: Letter Combinations of a Phone Number]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-17-Letter-Combinations-of-a-Phone-Number%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 785: Is Graph Bipartite?]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-785-Is-Graph-Bipartite%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 684: Redundant Connection]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-684-Redundant-Connection%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 444: Sequence Reconstruction]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-444-Sequence-Reconstruction%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 399: Evaluate Division]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-399-Evaluate-Division%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 310: Minimum Height Trees]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-310-Minimum-Height-Trees%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 210: Course Schedule II]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-210-Course-Schedule-II%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 207: Course Schedule]]></title>
    <url>%2F2018%2F10%2F14%2FLeetCode-207-Course-Schedule%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 662: Maximum Width of Binary Tree]]></title>
    <url>%2F2018%2F10%2F09%2FLeetCode-662-Maximum-Width-of-Binary-Tree%2F</url>
    <content type="text"><![CDATA[12345type TreeNode struct &#123; Val int Left *TreeNode Right *TreeNode&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445func widthOfBinaryTree(root *TreeNode) int &#123; if root == nil &#123; return 0 &#125; var res int var level uint var queue1, queue2 []*TreeNode queue1 = append(queue1, root) queue2 = append(queue2, root) for len(queue1) != 0 &#123; for _, v1 := range queue1 &#123; if v1.Left != nil &#123; queue1 = append(queue1, v1.Left) &#125; if v1.Right != nil &#123; queue1 = append(queue1, v1.Right) &#125; queue1 = queue1[1:] &#125; for _, v2 := range queue2 &#123; if v2 != nil &#123; if v2.Left != nil &#123; queue2 = append(queue2, v2.Left) &#125;else &#123; queue2 = append(queue2, nil) &#125; if v2.Right != nil &#123; queue2 = append(queue2, v2.Right) &#125;else &#123; queue2 = append(queue2, nil) &#125; &#125; queue2 = queue2[1:] &#125; if queue2[0] == nil || queue2[len(queue2)-1] == nil &#123; if res &lt; len(queue1) &#123; res = len(queue1) &#125; &#125;else &#123; res = (1 &lt;&lt; level) &#125; level++ &#125; return res&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 872: Leaf-Similar Trees]]></title>
    <url>%2F2018%2F10%2F09%2FLeetCode-872-Leaf-Similar-Trees%2F</url>
    <content type="text"><![CDATA[12345type TreeNode struct &#123; Val int Left *TreeNode Right *TreeNode&#125; 123456789func equal(s, t *TreeNode) bool &#123; if s == nil &amp;&amp; t == nil &#123; return true &#125; if s == nil || t == nil || s.Val != t.Val &#123; return false &#125; return equal(s.Left, t.Left) &amp;&amp; equal(s.Right, t.Right)&#125; 123456789101112func isSubtree(s *TreeNode, t *TreeNode) bool &#123; if t == nil &#123; return true &#125; if s == nil &amp;&amp; t != nil &#123; return false &#125; if equal(s, t) &#123; return true &#125; return isSubtree(s.Left, t) || isSubtree(s.Right, t)&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 742: Closest Leaf in a Binary Tree]]></title>
    <url>%2F2018%2F10%2F09%2FLeetCode-742-Closest-Leaf-in-a-Binary-Tree%2F</url>
    <content type="text"><![CDATA[12345type TreeNode struct &#123; Val int Left *TreeNode Right *TreeNode&#125; 12345type Record struct &#123; m map[*TreeNode]*TreeNode&#125;var back Record 1234567891011121314151617181920func find(root *TreeNode, k int) *TreeNode &#123; if root.Val == k &#123; return root &#125; if root.Left != nil &#123; back.m[root.Left.Val] = root left := find(root.Left, k) if left != nil &#123; return left &#125; &#125; if root.Right != nil &#123; back.m[root.Right.Val] = root right := find(root.Right, k) if right != nil &#123; return right &#125; &#125; return nil&#125; 12345678910111213141516171819202122232425262728293031func findClosestLeaf(root *TreeNode, k int) int &#123; back.m = make(map[int]*TreeNode) visited := make(map[int]*TreeNode) kNode := find(root, k) var q []*TreeNode q = append(q, kNode) visited[kNode.Val] = kNode for len(q) != 0 &#123; for _, v := range q &#123; if v.Left == nil &amp;&amp; v.Right == nil &#123; return v.Val &#125; if v.Left != nil &#123; visited[v.Left.Val] = v.Left q = append(q, v.Left) &#125; if v.Right != nil &#123; visited[v.Right.Val] = v.Right q = append(q, v.Right) &#125; _, isBack := back.m[v.Val] _, isVisited := visited[v.Val] if isBack &amp;&amp; !isVisited &#123; visited[v.Val] = v q = append(q, back.m[v.Val]) &#125; q = q[1:] &#125; &#125; return -1&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 687: Longest Univalue Path]]></title>
    <url>%2F2018%2F10%2F09%2FLeetCode-687-Longest-Univalue-Path%2F</url>
    <content type="text"><![CDATA[Given a binary tree, find the length of the longest path where each node in the path has the same value. This path may or may not pass through the root. Note: The length of path between two nodes is represented by the number of edges between them. Example 1: Input: 5 / \ 4 5 / \ \ 1 1 5 Output: 2 Example 2: Input: 1 / \ 4 5 / \ \ 4 4 5 Output: 2Note: The given binary tree has not more than 10000 nodes. The height of the tree is not more than 1000. 12345type TreeNode struct &#123; Val int Left *TreeNode Right *TreeNode&#125; 1234567891011121314151617181920212223242526272829func longestPath(root, parent *TreeNode, res *int) int &#123; if root == nil &#123; return 0 &#125; left := longestPath(root.Left, root, res) right := longestPath(root.Right, root, res) if root.Left != nil &amp;&amp; root.Val == root.Left.Val &#123; left++ &#125;else &#123; left = 0 &#125; if root.Right != nil &amp;&amp; root.Val == root.Right.Val &#123; right++ &#125;else &#123; right = 0 &#125; if *res &lt; left + right &#123; *res = left + right &#125; if left &lt; right &#123; left = right &#125; return left&#125; 12345678func longestUnivaluePath(root *TreeNode) int &#123; if root == nil &#123; return 0 &#125; res := 0 longestPath(root, root, &amp;res) return res&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 653: Two Sum IV - Input is a BST]]></title>
    <url>%2F2018%2F10%2F09%2FLeetCode-653-Two-Sum-IV-Input-is-a-BST%2F</url>
    <content type="text"><![CDATA[12345type TreeNode struct &#123; Val int Left *TreeNode Right *TreeNode&#125; 12345678910111213141516171819202122232425func findTarget(root *TreeNode, k int) bool &#123; if root == nil &#123; return false &#125; var queue []*TreeNode queue = append(queue, root) m := make(map[int]int) for len(queue) != 0 &#123; for _, v := range queue &#123; if v.Left != nil &#123; queue = append(queue, v.Left) &#125; if v.Right != nil &#123; queue = append(queue, v.Right) &#125; if _, exist := m[v.Val]; exist &#123; return true &#125;else &#123; m[k-v.Val] = v.Val &#125; queue = queue[1:] &#125; &#125; return false&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 652: Find Duplicate Subtrees]]></title>
    <url>%2F2018%2F10%2F09%2FLeetCode-652-Find-Duplicate-Subtrees%2F</url>
    <content type="text"><![CDATA[12345type TreeNode struct &#123; Val int Left *TreeNode Right *TreeNode&#125; 1234type Record struct &#123; m map[string]int&#125;var rec Record 12345678910111213141516func findDuplicate(root *TreeNode, res *[]*TreeNode) string &#123; if root == nil &#123; return "#" &#125; str := string(root.Val) + "," + findDuplicate(root.Left, res) + "," + findDuplicate(root.Right, res) if _, exist := rec.m[str]; exist &#123; if rec.m[str] == 1 &#123; *res = append(*res, root) &#125; rec.m[str]++ &#125;else &#123; rec.m[str] = 1 &#125; return str&#125; 123456func findDuplicateSubtrees(root *TreeNode) []*TreeNode &#123; var res []*TreeNode rec.m = make(map[string]int) findDuplicate(root, &amp;res) return res&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 572: Subtree of Another Tree]]></title>
    <url>%2F2018%2F10%2F09%2FLeetCode-572-Subtree-of-Another-Tree%2F</url>
    <content type="text"><![CDATA[12345type TreeNode struct &#123; Val int Left *TreeNode Right *TreeNode&#125; 123456789func equal(s, t *TreeNode) bool &#123; if s == nil &amp;&amp; t == nil &#123; return true &#125; if s == nil || t == nil || s.Val != t.Val &#123; return false &#125; return equal(s.Left, t.Left) &amp;&amp; equal(s.Right, t.Right)&#125; 123456789101112func isSubtree(s *TreeNode, t *TreeNode) bool &#123; if t == nil &#123; return true &#125; if s == nil &amp;&amp; t != nil &#123; return false &#125; if equal(s, t) &#123; return true &#125; return isSubtree(s.Left, t) || isSubtree(s.Right, t)&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 549: Binary Tree Longest Consecutive Sequence II]]></title>
    <url>%2F2018%2F10%2F09%2FLeetCode-549-Binary-Tree-Longest-Consecutive-Sequence-II%2F</url>
    <content type="text"><![CDATA[12345type TreeNode struct &#123; Val int Left *TreeNode Right *TreeNode&#125; 12345678910111213141516func currentLongest(root *TreeNode, diff int) int &#123; if root == nil &#123; return 0 &#125; left, right := 0, 0 if root.Left != nil &amp;&amp; root.Val - root.Left.Val == diff &#123; left = 1 + currentLongest(root.Left, diff) &#125; if root.Right != nil &amp;&amp; root.Val - root.Right.Val == diff &#123; right = 1 + currentLongest(root.Right, diff) &#125; if left &lt; right &#123; left = right &#125; return left&#125; 123456789101112131415161718func longestConsecutive(root *TreeNode) int &#123; if root == nil &#123; return 0 &#125; res := currentLongest(root, 1) + currentLongest(root, -1) + 1 left := longestConsecutive(root.Left) right := longestConsecutive(root.Right) if left &gt; right &#123; if left &gt; res &#123; res = left &#125; &#125;else &#123; if right &gt; res &#123; res = right &#125; &#125; return res&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 543: Diameter of Binary Tree]]></title>
    <url>%2F2018%2F10%2F09%2FLeetCode-543-Diameter-of-Binary-Tree%2F</url>
    <content type="text"><![CDATA[12345type TreeNode struct &#123; Val int Left *TreeNode Right *TreeNode&#125; 12345678910111213141516func maxDepth(root *TreeNode, res *int) int &#123; if root == nil &#123; return 0 &#125; left := maxDepth(root.Left, res) right := maxDepth(root.Right, res) if left + right &gt; *res &#123; *res = left + right &#125; if left &lt; right &#123; left = right &#125; return left + 1&#125; 12345func diameterOfBinaryTree(root *TreeNode) int &#123; res := 0 maxDepth(root, &amp;res) return res&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 250: Count Univalue Subtrees]]></title>
    <url>%2F2018%2F10%2F06%2FLeetCode-250-Count-Univalue-Subtrees%2F</url>
    <content type="text"><![CDATA[12345type TreeNode struct &#123; Val int Left *TreeNode Right *TreeNode&#125; 1234567891011func dfs(root *TreeNode, val int, res *int) bool &#123; if root == nil &#123; return true &#125; left := dfs(root.Left,root.Val,res) right := dfs(root.Right,root.Val,res) if left &amp;&amp; right &#123; *res++ &#125; return (root.Val == val) &amp;&amp; left &amp;&amp; right&#125; 12345678func countUnivalSubtrees(root *TreeNode) int &#123; res := 0 if root == nil &#123; return res &#125; dfs(root, root.Val, &amp;res) return res&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 226: Invert Binary Tree]]></title>
    <url>%2F2018%2F10%2F06%2FLeetCode-226-Invert-Binary-Tree%2F</url>
    <content type="text"><![CDATA[12345type TreeNode struct &#123; Val int Left *TreeNode Right *TreeNode&#125; 123456789101112131415func invertTree(root *TreeNode) *TreeNode &#123; if root == nil &#123; return root &#125; var left, right *TreeNode if root.Left != nil &#123; right = invertTree(root.Left) &#125; if root.Right != nil &#123; left = invertTree(root.Right) &#125; root.Left = left root.Right = right return root&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 222: Count Complete Tree Nodes]]></title>
    <url>%2F2018%2F10%2F06%2FLeetCode-222-Count-Complete-Tree-Nodes%2F</url>
    <content type="text"><![CDATA[12345type TreeNode struct &#123; Val int Left *TreeNode Right *TreeNode&#125; 1234567891011121314151617181920func countNodes(root *TreeNode) int &#123; if root == nil &#123; return 0 &#125; res := 0 queue := []*TreeNode&#123;root&#125; for len(queue) != 0 &#123; res = res + len(queue) for _, v := range queue &#123; if v.Left != nil &#123; queue = append(queue, v.Left) &#125; if v.Right != nil &#123; queue = append(queue, v.Right) &#125; queue = queue[1:] &#125; &#125; return res&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 124: Binary Tree Maximum Path Sum]]></title>
    <url>%2F2018%2F10%2F06%2FLeetCode-124-Binary-Tree-Maximum-Path-Sum%2F</url>
    <content type="text"><![CDATA[12345type TreeNode struct &#123; Val int Left *TreeNode Right *TreeNode&#125; 123456789101112131415161718192021222324func maxPath(root *TreeNode, res *int) int &#123; if root == nil &#123; return 0 &#125; left := maxPath(root.Left, res) if left &lt; 0 &#123; left = 0 &#125; right := maxPath(root.Right, res) if right &lt; 0 &#123; right = 0 &#125; if left + right + root.Val &gt; *res &#123; *res = left + right + root.Val &#125; if left &lt; right &#123; left = right &#125; return root.Val + left&#125; 12345func maxPathSum(root *TreeNode) int &#123; res := -0x7FFFFFFF maxPath(root, &amp;res) return res&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 110: Balanced Binary Tree]]></title>
    <url>%2F2018%2F10%2F06%2FLeetCode-110-Balanced-Binary-Tree%2F</url>
    <content type="text"><![CDATA[12345type TreeNode struct &#123; Val int Left *TreeNode Right *TreeNode&#125; 123456789101112131415161718192021func checkDepth(root *TreeNode) int &#123; if root == nil &#123; return 0 &#125; left := checkDepth(root.Left) if left == -1 &#123; return -1 &#125; right := checkDepth(root.Right) if right == -1 &#123; return -1 &#125; if right &gt; left &#123; left, right = right, left &#125; diff := left - right if diff &gt; 1 &#123; return -1 &#125; return 1 + left&#125; 123456func isBalanced(root *TreeNode) bool &#123; if checkDepth(root) == -1 &#123; return false &#125; return true&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 108: Convert Sorted Array to Binary Search Tree]]></title>
    <url>%2F2018%2F10%2F06%2FLeetCode-108-Convert-Sorted-Array-to-Binary-Search-Tree%2F</url>
    <content type="text"><![CDATA[12345type TreeNode struct &#123; Val int Left *TreeNode Right *TreeNode&#125; 12345678910111213141516171819func sortedArrayToBST(nums []int) *TreeNode &#123; if len(nums) == 0 &#123; return nil &#125;else if len(nums) == 1 &#123; res1 := &amp;TreeNode&#123;Val: nums[0],Left: nil,Right: nil&#125; return res1 &#125;else if len(nums) == 2 &#123; resNode := &amp;TreeNode&#123;Val: nums[0],Left: nil,Right: nil&#125; res2 := &amp;TreeNode&#123;Val: nums[1],Left: resNode,Right: nil&#125; return res2 &#125; key := len(nums) / 2 left := nums[:key] right := nums[key+1:] res := &amp;TreeNode&#123;Val: nums[key], Left: sortedArrayToBST(left),Right: sortedArrayToBST(right)&#125; return res&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 104: Maximum Depth of Binary Tree]]></title>
    <url>%2F2018%2F10%2F06%2FLeetCode-104-Maximum-Depth-of-Binary-Tree%2F</url>
    <content type="text"><![CDATA[12345type TreeNode struct &#123; Val int Left *TreeNode Right *TreeNode&#125; 123456789101112131415161718192021func maxDepth(root *TreeNode) int &#123; res := 0 if root == nil &#123; return res &#125; var queue []*TreeNode queue = append(queue, root) for len(queue) != 0 &#123; for _, v := range queue &#123; if v.Left != nil &#123; queue = append(queue, v.Left) &#125; if v.Right != nil &#123; queue = append(queue, v.Right) &#125; queue = queue[1:] &#125; res++ &#125; return res&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 103: Binary Tree Zigzag Level Order Traversal]]></title>
    <url>%2F2018%2F10%2F06%2FLeetCode-103-Binary-Tree-Zigzag-Level-Order-Traversal%2F</url>
    <content type="text"><![CDATA[12345type TreeNode struct &#123; Val int Left *TreeNode Right *TreeNode&#125; 12345678910111213141516171819202122232425262728293031323334353637383940func zigzagLevelOrder(root *TreeNode) [][]int &#123; var res [][]int if root == nil &#123; return res &#125; var s1, s2 []*TreeNode s1 = append(s1, root) for len(s1) != 0 || len(s2) != 0 &#123; var level1 []int for _, v1 := range s1 &#123; level1 = append(level1, v1.Val) if v1.Right != nil &#123; s2 = append(s2, v1.Right) &#125; if v1.Left != nil &#123; s2 = append(s2, v1.Left) &#125; s1 = s1[1:] &#125; if len(level1) != 0 &#123; res = append(res, level1) &#125; var level2 []int for _, v2 := range s2 &#123; level2 = append(level2, v2.Val) if v2.Left != nil &#123; s1 = append(s1, v2.Left) &#125; if v2.Right != nil &#123; s1 = append(s1, v2.Right) &#125; s2 = s2[1:] &#125; if len(level2) != 0 &#123; res = append(res, level2) &#125; &#125; return res&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Binary Tree</tag>
        <tag>Not solved</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 102: Binary Tree Level Order Traversal]]></title>
    <url>%2F2018%2F10%2F06%2FLeetCode-102-Binary-Tree-Level-Order-Traversal%2F</url>
    <content type="text"><![CDATA[12345type TreeNode struct &#123; Val int Left *TreeNode Right *TreeNode&#125; 1234567891011121314151617181920212223func levelOrder(root *TreeNode) [][]int &#123; var res [][]int if root == nil &#123; return res &#125; var queue []*TreeNode queue = append(queue, root) for len(queue) != 0 &#123; var oneLevel []int for _, v := range queue &#123; oneLevel = append(oneLevel, v.Val) if v.Left != nil &#123; queue = append(queue, v.Left) &#125; if v.Right != nil &#123; queue = append(queue, v.Right) &#125; queue = queue[1:] &#125; res = append(res,oneLevel) &#125; return res&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 98: Validate Binary Search Tree]]></title>
    <url>%2F2018%2F10%2F06%2FLeetCode-98-Validate-Binary-Search-Tree%2F</url>
    <content type="text"><![CDATA[12345type TreeNode struct &#123; Val int Left *TreeNode Right *TreeNode&#125; 12345678910func isBST(root *TreeNode, min, max int) bool &#123; if root == nil &#123; return true &#125; if root.Val &lt;= min || root.Val &gt;= max &#123; return false &#125; return isBST(root.Left,min,root.Val) &amp;&amp; isBST(root.Right,root.Val,max)&#125; 123func isValidBST(root *TreeNode) bool &#123; return isBST(root, -int(^uint(0) &gt;&gt; 1)-1, int(^uint(0) &gt;&gt; 1))&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 725: Split Linked List in Parts]]></title>
    <url>%2F2018%2F10%2F04%2FLeetCode-725-Split-Linked-List-in-Parts%2F</url>
    <content type="text"><![CDATA[1234type ListNode struct &#123; Val int Next *ListNode&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546func splitListToParts(root *ListNode, k int) []*ListNode &#123; var res []*ListNode var n int tmp := root for tmp != nil &#123; tmp = tmp.Next n++ &#125; if n &lt; k &#123; for t := 0; t &lt; n; t++ &#123; shortTmp := root root = root.Next shortTmp.Next = nil res = append(res, shortTmp) &#125; for u := n; u &lt; k; u++ &#123; shortTmp := new(ListNode) res = append(res, shortTmp.Next) &#125; return res &#125; usual, more := n / k, n % k for i := 0; i &lt; more; i++ &#123; listTmp := root for t := 0; t &lt; usual; t++ &#123; root = root.Next &#125; now := root.Next root.Next = nil res = append(res, listTmp) root = now &#125; for j := 0; j &lt; k - more; j++ &#123; longTmp := root for n := 0; n &lt; usual - 1; n++ &#123; root = root.Next &#125; now := root.Next root.Next = nil res = append(res, longTmp) root = now &#125; return res&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 445: Add Two Numbers II]]></title>
    <url>%2F2018%2F10%2F04%2FLeetCode-445-Add-Two-Numbers-II%2F</url>
    <content type="text"><![CDATA[1234type ListNode struct &#123; Val int Next *ListNode&#125; 12345678910111213141516171819202122232425262728293031func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode &#123; var s1, s2 []int for l1 != nil &#123; s1 = append(s1, l1.Val) l1 = l1.Next &#125; for l2 != nil &#123; s2 = append(s2, l2.Val) l2 = l2.Next &#125; var sum int res := new(ListNode) for len(s1) != 0 || len(s2) != 0 &#123; if len(s1) != 0 &#123; sum += s1[len(s1)-1] s1 = s1[:len(s1)-1] &#125; if len(s2) != 0 &#123; sum += s2[len(s2)-1] s2 = s2[:len(s2)-1] &#125; res.Val = sum % 10 head := &amp;ListNode&#123;sum / 10, res&#125; res = head sum = sum / 10 &#125; if res.Val == 0 &#123; return res.Next &#125; return res&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 206: Reverse Linked List]]></title>
    <url>%2F2018%2F10%2F04%2FLeetCode-206-Reverse-Linked-List%2F</url>
    <content type="text"><![CDATA[1234type ListNode struct &#123; Val int Next *ListNode&#125; 12345678910func reverseList(head *ListNode) *ListNode &#123; var res *ListNode for head != nil &#123; temp := head.Next head.Next = res res = head head = temp &#125; return res&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 19: Remove Nth Node From End of List]]></title>
    <url>%2F2018%2F10%2F04%2FLeetCode-19-Remove-Nth-Node-From-End-of-List%2F</url>
    <content type="text"><![CDATA[1234type ListNode struct &#123; Val int Next *ListNode&#125; 123456789101112131415161718192021func removeNthFromEnd(head *ListNode, n int) *ListNode &#123; ahead, res := head, head for i := 0; i &lt; n; i++ &#123; ahead = ahead.Next &#125; if ahead == nil &#123; return res.Next &#125; for ahead.Next != nil &#123; ahead = ahead.Next head = head.Next &#125; if head.Next != nil &#123; head.Next = head.Next.Next &#125;else &#123; head.Next = nil &#125; return res&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 817: Linked List Components]]></title>
    <url>%2F2018%2F10%2F03%2FLeetCode-817-Linked-List-Components%2F</url>
    <content type="text"><![CDATA[1234type ListNode struct &#123; Val int Next *ListNode&#125; 12345678910111213141516171819func numComponents(head *ListNode, G []int) int &#123; m := make(map[int]bool) for _, v := range G &#123; m[v] = true &#125; var res int for head.Next != nil &#123; _, exist1 := m[head.Val] _, exist2 := m[head.Next.Val] if exist1 &amp;&amp; (head.Next == nil || !exist2) &#123; res++ &#125; head = head.Next &#125; if _, exist := m[head.Val]; exist &#123; res++ &#125; return res&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 369: Plus One Linked List]]></title>
    <url>%2F2018%2F10%2F03%2FLeetCode-369-Plus-One-Linked-List%2F</url>
    <content type="text"><![CDATA[1234type ListNode struct &#123; Val int Next *ListNode&#125; 1234567891011121314func everyOne(head *ListNode) (*ListNode, int) &#123; if head.Next == nil &#123; carry := (head.Val + 1) / 10 head.Val = (head.Val + 1) % 10 return head, carry &#125; res, carry := everyOne(head.Next) if carry == 1 &#123; carry = (head.Val + 1) / 10 head.Val = (head.Val + 1) % 10 &#125; head.Next = res return head, carry&#125; 12345678func plusOne(head *ListNode) *ListNode &#123; res, carry := everyOne(head) if carry == 1 &#123; newHead := &amp;ListNode&#123;1, res&#125; return newHead &#125; return res&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 203: Remove Linked List Elements]]></title>
    <url>%2F2018%2F10%2F03%2FLeetCode-203-Remove-Linked-List-Elements%2F</url>
    <content type="text"><![CDATA[1234type ListNode struct &#123; Val int Next *ListNode&#125; 12345678910111213func removeElements(head *ListNode, val int) *ListNode &#123; newHead := new(ListNode) newHead.Next = head tail := newHead for tail != nil &#123; if tail.Next.Val == val &#123; tail.Next = tail.Next.Next &#125;else &#123; tail = tail.Next &#125; &#125; return newHead.Next&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 21: Merge Two Sorted Lists]]></title>
    <url>%2F2018%2F10%2F03%2FLeetCode-21-Merge-Two-Sorted-Lists%2F</url>
    <content type="text"><![CDATA[1234type ListNode struct &#123; Val int Next *ListNode&#125; 123456789101112131415161718192021func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode &#123; head := new(ListNode) tail := head for l1 != nil &amp;&amp; l2 != nil &#123; if l1.Val &lt;= l2.Val &#123; tail.Next = l1 tail = l1 l1 = l1.Next &#125;else &#123; tail.Next = l2 tail = l2 l2 = l2.Next &#125; &#125; if l1 == nil &#123; tail.Next = l2 &#125;else &#123; tail.Next = l1 &#125; return head.Next&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 750: Number Of Corner Rectangles]]></title>
    <url>%2F2018%2F10%2F03%2FLeetCode-750-Number-Of-Corner-Rectangles%2F</url>
    <content type="text"><![CDATA[123456789101112131415func countCornerRectangles(grid [][]int) int &#123; var res int for i := 0; i &lt; len(grid); i++ &#123; for j := i + 1; j &lt; len(grid); j++ &#123; count := 0 for k := 0; k &lt; len(grid[0]); k++ &#123; if grid[i][k] == 1 &amp;&amp; grid[j][k] == 1 &#123; count++ &#125; &#125; res += count * (count - 1) / 2 &#125; &#125; return res &#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode 418: Sentence Screen Fitting]]></title>
    <url>%2F2018%2F10%2F02%2FLeetcode-418-Sentence-Screen-Fitting%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526func wordsTyping(sentence []string, rows int, cols int) int &#123; left, res, count := cols, 0, 0 for i := 0; i &lt; rows; i++ &#123; for &#123; if count == len(sentence) &#123; count = 0 res += 1 &#125; if left &lt; len(sentence[count]) &#123; left = cols break &#125;else if left == len(sentence[count]) &#123; count++ left = cols break &#125; left -= len(sentence[count]) + 1 count++ &#125; &#125; if count == len(sentence) &#123; count = 0 res += 1 &#125; return res&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode 416: Partition Equal Subset Sum]]></title>
    <url>%2F2018%2F10%2F02%2FLeetcode-416-Partition-Equal-Subset-Sum%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920func canPartition(nums []int) bool &#123; var sum, target int for _, v := range nums &#123; sum += v &#125; if sum % 2 == 1 &#123; return false &#125;else &#123; target = sum &gt;&gt; 1 &#125; dp := make([]bool, target + 1) dp[0] = true for _, n := range nums &#123; for i := target; i &gt;= n; i-- &#123; dp[i] = dp[i] || dp[i - n] &#125; &#125; return dp[target] &#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 375: Guess Number Higher or Lower II]]></title>
    <url>%2F2018%2F09%2F28%2FLeetCode-375-Guess-Number-Higher-or-Lower-II%2F</url>
    <content type="text"><![CDATA[1234567func getMoneyAmount(n int) int &#123; m := make([][]int, n + 1) for t := range m &#123; m[t] = make([]int, n + 1) &#125; return guessMoney(1, n, m)&#125; 123456789101112131415161718192021222324func guessMoney(start, end int, m [][]int) int &#123; if start &gt;= end &#123; return 0 &#125; if m[start][end] &gt; 0 &#123; return m[start][end] &#125; res := 0x7FFFFFFF for i := start; i &lt; end; i++ &#123; a := guessMoney(start, i - 1, m) b := guessMoney(i + 1, end, m) if a &gt; b &#123; if i + a &lt; res &#123; res = i + a &#125; &#125;else &#123; if i + b &lt; res &#123; res = i + b &#125; &#125; &#125; m[start][end] = res return res&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
        <tag>Minimax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 304: Range Sum Query 2D - Immutable]]></title>
    <url>%2F2018%2F09%2F28%2FLeetCode-304-Range-Sum-Query-2D-Immutable%2F</url>
    <content type="text"><![CDATA[123type NumMatrix struct &#123; dp [][]int&#125; 12345678910111213141516171819202122func Constructor(matrix [][]int) NumMatrix &#123; var m, n int if len(matrix) == 0 || len(matrix[0]) == 0 &#123; m, n = 0, 0 &#125;else &#123; m, n = len(matrix), len(matrix[0]) &#125; dp := make([][]int, m + 1) for v := range dp &#123; dp[v] = make([]int, n + 1) &#125; for i := 1; i &lt;= m; i++ &#123; for j := 1; j &lt;=n; j++ &#123; dp[i][j] = matrix[i-1][j-1] + dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1] &#125; &#125; return NumMatrix&#123;dp: dp&#125;&#125;func (this *NumMatrix) SumRegion(row1 int, col1 int, row2 int, col2 int) int &#123; return this.dp[row2+1][col2+1] - this.dp[row2+1][col1] - this.dp[row1][col2+1] + this.dp[row1][col1]&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 221: Maximal Square]]></title>
    <url>%2F2018%2F09%2F28%2FLeetCode-221-Maximal-Square%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435func maximalSquare(matrix [][]byte) int &#123; if len(matrix) == 0 || len(matrix[0]) == 0 &#123; return 0 &#125; res := 0 dp := make([][]int, len(matrix)) for t := range dp &#123; dp[t] = make([]int, len(matrix[0])) &#125; for i := range matrix &#123; for j := range matrix[i] &#123; if i == 0 || j == 0 &#123; dp[i][j] = int(matrix[i][j]) - '0' &#125;else if int(matrix[i][j]) == '1' &#123; if dp[i-1][j] &lt; dp[i][j-1] &#123; if dp[i-1][j] &lt; dp[i-1][j-1] &#123; dp [i][j] = dp[i-1][j] + 1 &#125;else &#123; dp[i][j] = dp[i-1][j-1] + 1 &#125; &#125;else &#123; if dp[i][j-1] &lt; dp[i-1][j-1] &#123; dp [i][j] = dp[i][j-1] + 1 &#125;else &#123; dp[i][j] = dp[i-1][j-1] + 1 &#125; &#125; &#125; if res &lt; dp[i][j] &#123; res = dp[i][j] &#125; &#125; &#125; return res * res &#125; 1234567891011121314151617181920212223242526272829303132333435func maximalSquare(matrix [][]byte) int &#123; if len(matrix) == 0 || len(matrix[0]) == 0 &#123; return 0 &#125; dp := [2][]int&#123;make([]int, len(matrix[0])+1), make([]int, len(matrix[0])+1)&#125; res, curr := 0, 0 for i := range matrix &#123; prev := curr curr = 1 - curr for j := range matrix[i] &#123; if matrix[i][j] == '0' &#123; dp[curr][j+1] = 0 continue &#125; if dp[curr][j] &lt; dp[prev][j] &#123; if dp[curr][j] &lt; dp[prev][j+1] &#123; dp[curr][j+1] = dp[curr][j] + 1 &#125;else &#123; dp[curr][j+1] = dp[prev][j+1] + 1 &#125; &#125;else &#123; if dp[prev][j] &lt; dp[prev][j+1] &#123; dp[curr][j+1] = dp[prev][j] + 1 &#125;else &#123; dp[curr][j+1] = dp[prev][j+1] + 1 &#125; &#125; if res &lt; dp[curr][j+1] &#123; res = dp[curr][j+1] &#125; &#125; &#125; return res * res&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 198: House Robber]]></title>
    <url>%2F2018%2F09%2F28%2FLeetCode-198-House-Robber%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324func rob(nums []int) int &#123; var even, odd, res int for i, v := range nums &#123; if i % 2 == 0 &#123; if even + v &gt; odd &#123; even = even + v &#125;else &#123; even = odd &#125; &#125;else &#123; if odd + v &gt; even &#123; odd = odd + v &#125;else &#123; odd = even &#125; &#125; &#125; if even &gt; odd &#123; res = even &#125;else &#123; res = odd &#125; return res&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 188: Best Time to Buy and Sell Stock IV]]></title>
    <url>%2F2018%2F09%2F28%2FLeetCode-188-Best-Time-to-Buy-and-Sell-Stock-IV%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122func maxProfit(k int, prices []int) int &#123; if k &gt; len(prices) &#123; k = len(prices) &#125; var bp, sp []int for i := 0; i &lt; k; i++ &#123; bp = append(bp, -0x80000000) sp = append(sp, 0) &#125; sp = append(sp, 0) for _, v := range prices &#123; for j := 0; j &lt; k; j++ &#123; if bp[i] &lt; sp[i] - v &#123; bp[i] = sp[i] - v &#125; if sp[i+1] &lt; v + bp[i] &#123; sp[i+1] = v + bp[i] &#125; &#125; &#125; return sp[k]&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 139: Word Break]]></title>
    <url>%2F2018%2F09%2F28%2FLeetCode-139-Word-Break%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526func wordBreak(s string, wordDict []string) bool &#123; if len(wordDict) == 0 &#123; return false &#125; dict := make(map[string]bool) length := []int for _, v := range wordDict &#123; if _, exist := dict[v]; !exist &#123; dict[v] = true length = append(length,len(v)) &#125; &#125; dp := make([]bool, len(s)+1) dp[0] = true for i := 0; i &lt; len(s); i++ &#123; if !dp[i] &#123; continue &#125; for _, size := range length &#123; dp[i+size] = dp[i+size] || dict[s[i:i+size]] &#125; &#125; return dp[len(s)]&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 10: Regular Expression Matching]]></title>
    <url>%2F2018%2F09%2F28%2FLeetCode-10-Regular-Expression-Matching%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819func isMatch(s string, p string) bool &#123; dp := make([][]bool, len(s)+1) for i := range dp &#123; dp[i] = make([]bool, len(p)+1) &#125; dp[len(s)][len(p)] = true for i := len(s); i &gt;= 0; i-- &#123; for j := len(p) - 1; j &gt;= 0; j-- &#123; firstMatch := i &lt; len(s) &amp;&amp; (p[j] == s[i] || p[j] == '.') if j+1 &lt; len(p) &amp;&amp; p[j + 1] == '*' &#123; dp[i][j] = dp[i][j + 2] || firstMatch &amp;&amp; dp[i + 1][j] &#125;else &#123; dp[i][j] = firstMatch &amp;&amp; dp[i + 1][j + 1] &#125; &#125; &#125; return dp[0][0]&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 8: String to Integer (atoi)]]></title>
    <url>%2F2018%2F09%2F28%2FLeetCode-8-String-to-Integer-atoi%2F</url>
    <content type="text"><![CDATA[This is following: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748func myAtoi(str string) int &#123; s := strings.TrimSpace(str) if len(s) == 0 &#123; return 0 &#125; symbol := ‘+’ if s[0] == ‘-’ &#123; symbol = ‘-’ s = s[1:] &#125;else s[0] == ‘+’ &#123; s = s[1:] &#125; if len(s) == 0 &#123; return 0 &#125; if s[0] &lt; ‘0’ || s[0] &gt; ‘9’ &#123; return 0 &#125; for i := range s &#123; if s[i] &lt; ‘0’ || s[i] &gt; ‘9’ &#123; s = s[:i] break &#125; &#125; res := 0 for _, ch := range []byte(s) &#123; ch -= ‘0’ if ch &gt; 9 &#123; return 0 &#125; res = res*10 + int(ch) if res &gt; 0x7FFFFFFF &#123; if symbol == ‘-’ &#123; return -0x80000000 &#125; return 0x7FFFFFFF &#125; &#125; if symbol == ‘-’ &#123; res = -res &#125; return res&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 7: Reverse Integer]]></title>
    <url>%2F2018%2F09%2F28%2FLeetCode-7-Reverse-Integer%2F</url>
    <content type="text"><![CDATA[1234567891011121314func reverse(x int) int &#123; res := 0 for &#123; res = res * 10 + x % 10 if x / 10 == 0 &#123; break &#125; x = x / 10 &#125; if x &lt; -0x80000000 || x &gt; 0x7FFFFFFF &#123; return 0 &#125; return res&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 5: Longest Palindromic Substring]]></title>
    <url>%2F2018%2F09%2F28%2FLeetCode-5-Longest-Palindromic-Substring%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526func longestPalindrome(s string) string &#123; if len(s) &lt; 2 &#123; return s &#125; index, max := 0, 0 for i := 0; i &lt; len(s) &#123; if len(s) - i &gt; max / 2 &#123; break &#125; begin, end := i, i for end &lt; len(s) - 1 &amp;&amp; s[i] == s[i+1] &#123; end++ &#125; i = end + 1 for end &lt; len(s) - 1 &amp;&amp; begin &gt; 0 &amp;&amp; s[end+1] == s[begin-1] &#123; end++ begin-- &#125; length := end - begin + 1 if max &lt; length &#123; max = length index = begin &#125; &#125; return s[index: index + max]&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 3: Longest Substring Without Repeating Characters]]></title>
    <url>%2F2018%2F09%2F28%2FLeetCode-3-Longest-Substring-Without-Repeating-Characters%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021func lengthOfLongestSubstring(s string) int &#123; m := make(map[uint8]int) res := 0 start, end := 0, 0 for end &lt; len(s) &#123; if p, exist := m[s[end]]; exist &#123; start = p + 1 end = start for k, _ := range m &#123; delete(m, k) &#125; &#125;else &#123; m[s[end]] = end if end - start + 1 &gt; res &#123; res = end - start + 1 &#125; end++ &#125; &#125; return res&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>Hash Table</tag>
        <tag>Two Pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 2: Add Two Numbers]]></title>
    <url>%2F2018%2F09%2F28%2FLeetCode-2-Add-Two-Numbers%2F</url>
    <content type="text"><![CDATA[1234type ListNode struct &#123; Val interface&#123;&#125; Next *ListNode&#125; 123456789101112131415161718192021func addTwoNumbers(a, b *ListNode) *ListNode &#123; head := new(ListNode) node := head carray := 0 for a != nil || b != nil || carray != 0 &#123; sum := carry if a != nil &#123; sum += a.Val a = a.Next &#125; if b != nil &#123; sum += b.Val b = b.Next &#125; carry = sum / 10 node.Next = new(ListNode) node.Next.Val = sum % 10 node = node.Next &#125; return head.Next&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 1: Two Sum]]></title>
    <url>%2F2018%2F09%2F27%2FLeetCode-1-Two-Sum%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617func twoSum(nums []int, target int) []int &#123; var res []int m := make(map[int]int) for i := 0; i &lt; len(nums); i++ &#123; if v,exist := m[target-nums[i]];exist &#123; if v &lt; i &#123; res = append(res,v,i) &#125;else &#123; res = append(res,i,v) &#125; break &#125;else &#123; m[nums[i]] = i &#125; &#125; return res&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Hash Table</tag>
      </tags>
  </entry>
</search>
